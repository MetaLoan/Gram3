
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crypto Signal 回测一键GUI（离线版 · Binance · v1.3）</title>
  <style>
    :root { --bg:#f8fafc; --card:#ffffff; --text:#0f172a; --muted:#64748b; --accent:#10b981; --border:#e2e8f0; --danger:#ef4444; --warn:#f59e0b;}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Sans","PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif}
    .container{max-width:1200px;margin:0 auto;padding:24px} h1{font-size:22px;margin:0} h2{font-size:16px;margin:0 0 8px 0}
    .row{display:grid;gap:16px} @media(min-width:1000px){.row{grid-template-columns:1fr 1fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:16px;box-shadow:0 2px 8px rgba(0,0,0,.04)}
    label{font-size:13px;color:var(--muted);display:block} input,select,textarea{width:100%;margin-top:6px;padding:10px 12px;border-radius:10px;border:1px solid var(--border);outline:none;font-size:14px}
    textarea{font-family:ui-monospace,Menlo,Monaco,"Courier New",monospace;height:180px;resize:vertical}
    .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:12px;border:1px solid var(--border);background:#fff;cursor:pointer;font-size:14px}
    .btn.primary{background:#0f172a;color:#fff;border-color:#000} .btn.success{background:var(--accent);color:#fff;border-color:var(--accent)} .btn:disabled{opacity:.6;pointer-events:none}
    .muted{color:var(--muted);font-size:12px} .stack{display:flex;flex-wrap:wrap;gap:8px;align-items:center;flex-wrap:wrap}
    table{width:100%;border-collapse:collapse;font-size:12px} th,td{padding:8px 10px;border-bottom:1px solid var(--border);text-align:left;vertical-align:middle}
    .stat{border:1px solid var(--border);border-radius:12px;padding:10px}.stat .label{color:var(--muted);font-size:12px}.stat .value{font-size:18px;font-weight:600;margin-top:6px}
    .header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}.pill{font-size:12px;color:var(--muted)}.grid4{display:grid;grid-template-columns:repeat(1,1fr);gap:12px}
    @media(min-width:1000px){.grid4{grid-template-columns:repeat(4,1, 1fr)}}
    .footer{color:var(--muted);font-size:12px;margin-top:16px}.hr{height:1px;background:var(--border);margin:12px 0}
    .hint{font-size:12px;color:var(--muted)} .hidden{opacity:.5;pointer-events:none}
    .badge{display:inline-block;padding:2px 6px;border-radius:999px;font-size:11px;border:1px solid var(--border);color:#334155;background:#f1f5f9}
    .badge.warn{color:#7c2d12;background:#fffbeb;border-color:#fde68a}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Crypto Signal 回测一键GUI（离线版 · Binance · v1.3）</h1>
      <div class="pill">本地执行；仅请求 Binance 公共 API 获取K线</div>
    </div>

    <div class="row">
      <div class="card">
        <h2>数据设置</h2>
        <div class="hr"></div>
        <div class="stack">
          <label style="display:flex;gap:8px;align-items:center">
            <input id="autoInfer" type="checkbox" checked />
            <span>从 <b>信号</b> 自动推断交易对与起始时间（推荐）</span>
          </label>
          <span class="hint">启用后自动识别 CSV 的 symbol 与最早 signal_time（前置缓冲），支持多品种。</span>
        </div>
        <div class="hr"></div>
        <div id="manualBox" class="row" style="grid-template-columns: 1fr 1fr; gap: 12px; opacity:.6">
          <div><label>交易对（手动模式时生效）
            <input id="symbol" placeholder="SOL/USDT" value="SOL/USDT" />
          </label></div>
          <div><label>市场
            <select id="market">
              <option value="spot">现货</option>
              <option value="um">USDⓈ-M 合约</option>
            </select>
          </label></div>
          <div><label>周期
            <input id="intervalInput" value="15m" />
            <div class="hint">可输入：1m/3m/5m/15m/30m/1h/2h/4h/6h/8h/12h/1d/3d/1w/1M；也兼容「1H」「15 min」「1 小时」等写法</div>
          </label></div>
          <div><label>Since (UTC，手动模式时生效)
            <input id="since" value="2025-01-01T00:00:00Z" />
          </label></div>
          <div style="grid-column: 1 / -1;"><label>Until (UTC，可留空)
            <input id="until" placeholder="" />
          </label></div>
        </div>
        <div class="stack" style="margin-top: 12px;">
          <button id="btnFetch" class="btn primary">仅拉取K线</button>
          <button id="btnOneClick" class="btn success">一键回测（拉取→计算）</button>
          <span class="muted" id="fetchedCount">已获取：0 根</span>
          <span class="badge" id="symBadge" title="已识别的交易对">—</span>
          <span class="badge warn" id="warnBadge" style="display:none;">已将非法周期修正为 15m</span>
        </div>
      </div>

      <div class="card">
        <h2>信号输入</h2>
        <div class="hr"></div>
        <div class="muted">列：signal_id,symbol,direction,leverage,entry_low,entry_high,tp1..tp5,sl,signal_time（UTC ISO）</div>
        <textarea id="signalsCSV">signal_id,symbol,direction,leverage,entry_low,entry_high,tp1,tp2,tp3,tp4,tp5,sl,signal_time
ex1,SOLUSDT,LONG,25,200.3,202.5,204.1,204.9,206.7,208.7,211.8,193.6,2025-01-15T08:00:00Z</textarea>
        <div class="stack">
          <input type="file" id="fileSignals" accept=".csv" />
          <label>同K线冲突策略
            <select id="conflict">
              <option value="conservative">保守（先SL）</option>
              <option value="optimistic">乐观（先TP）</option>
              <option value="hl_order" selected>路径假设（O→H→L→C / O→L→H→C）</option>
            </select>
          </label>
          <label>触碰即命中
            <select id="touch">
              <option value="true" selected>是</option>
              <option value="false">否</option>
            </select>
          </label>
          <button id="btnRun" class="btn">仅回测（使用已拉取K线）</button>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top: 16px;">
      <h2>总览</h2>
      <div class="hr"></div>
      <div class="grid4">
        <div class="stat"><div class="label">信号总数</div><div class="value" id="statTotal">0</div></div>
        <div class="stat"><div class="label">已成交数</div><div class="value" id="statFilled">0</div></div>
        <div class="stat"><div class="label">命中率 (TP_HIT/已成交)</div><div class="value" id="statHitRate">-</div></div>
        <div class="stat"><div class="label">最高浮盈（杠杆后，已成交）</div><div class="value" id="statMaxLev">-</div></div>
      </div>
    </div>

    <div class="card" style="margin-top: 16px; overflow: auto;">
      <h2>明细</h2>
      <div class="hr"></div>
      <table id="table">
        <thead>
          <tr>
            <th>signal_id</th><th>symbol</th><th>direction</th><th>status</th><th>fill_price</th>
            <th>tp_hit</th><th>sl_hit</th><th>best_tp_reached</th>
            <th>max_floating_raw_pct</th><th>max_floating_pnl_pct</th>
            <th>max_drawdown_raw_pct</th><th>max_drawdown_pct</th>
            <th>best_tp_yield_raw_pct</th><th>best_tp_yield_pct</th>
            <th>realized_raw_pct</th><th>realized_pct</th>
            <th>fill_time</th><th>exit_time</th><th>last_timestamp</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
      <div class="stack" style="margin-top: 8px;">
        <button id="btnExport" class="btn">导出结果CSV（可选）</button>
      </div>
    </div>

    <div class="footer">提示：输入如“1H”“15 min”“1 小时”等都会被自动标准化为 Binance 支持的周期；无法识别时将回退到 15m 并显示黄色提示。</div>
  </div>

  <script>
    // ---------- Helpers ----------
    const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
    const toMs = (d) => (d instanceof Date ? d.getTime() : new Date(d).getTime());
    const fmtPct = (x) => (x == null || Number.isNaN(x) ? "-" : (x * 100).toFixed(2) + "%");
    const fmtNum = (x, n = 4) => (x == null || Number.isNaN(x) ? "-" : Number(x).toFixed(n));
    const dl = (name, text) => { const a = document.createElement("a"); a.href = URL.createObjectURL(new Blob([text], { type: "text/csv;charset=utf-8;" })); a.download = name; a.click(); };
    const normSymbol = (input) => { if (!input) return ""; return input.includes("/") ? input.replace("/", "").toUpperCase() : input.toUpperCase(); };
    const uniq = (arr) => Array.from(new Set(arr));

    const BINANCE_INTERVALS = new Set(["1m","3m","5m","15m","30m","1h","2h","4h","6h","8h","12h","1d","3d","1w","1M"]);
    function standardizeInterval(input) {
      // Accept variants like " 15 MIN ", "1 H", "1小时", "1 小时", "1 周", "1 月"
      let s = String(input || "").trim();
      if (!s) return { val: "15m", fixed: true };
      // Direct match
      if (BINANCE_INTERVALS.has(s)) return { val: s, fixed: false };
      // Lowercase for words; keep trailing 'M' (month) special-case later
      let t = s.toLowerCase()
        .replace(/分钟|分|min|mins|minute|minutes/g, "m")
        .replace(/小时|时|hour|hours|hr|hrs/g, "h")
        .replace(/天|日|day|days/g, "d")
        .replace(/周|星期|week|weeks/g, "w")
        .replace(/月|month|months/g, "M")
        .replace(/\s+/g, "");
      // Normalize cases like '1H' -> '1h', '1M' stays '1M'
      // Extract number + unit
      const m = t.match(/^(\d+)([mhdwM])$/i);
      if (!m) return { val: "15m", fixed: true };
      const n = m[1];
      const u = m[2];
      const std = (u === "M") ? (n + "M") : (n + u.toLowerCase());
      // Validate against Binance's whitelist
      if (BINANCE_INTERVALS.has(std)) return { val: std, fixed: true };
      // Allow common minute bars like 2m/4m that Binance doesn't support -> round to nearest supported: 1m/3m/5m/15m/30m
      if (u.toLowerCase() === "m") {
        const num = parseInt(n, 10);
        const choices = [1,3,5,15,30];
        let best = 1, diff = 1e9;
        for (const c of choices) {
          const d = Math.abs(c - num);
          if (d < diff) { diff = d; best = c; }
        }
        return { val: best + "m", fixed: true };
      }
      // Fallback
      return { val: "15m", fixed: true };
    }

    function intervalToMs(interval) {
      const { val } = standardizeInterval(interval);
      const n = parseInt(val, 10);
      const u = val.replace(String(n), "");
      const map = { m: 60000, h: 3600000, d: 86400000, w: 604800000, M: 30*86400000 };
      return n * map[u];
    }

    // CSV parse/stringify
    function parseCSV(text) {
      const rows = String(text||"").trim().split(/\r?\n/);
      if (!rows[0]) return [];
      const header = splitCSVLine(rows[0]);
      return rows.slice(1).filter(Boolean).map((line) => {
        const cols = splitCSVLine(line);
        return Object.fromEntries(header.map((h, i) => [h, cols[i] ?? ""]));
      });
    }
    function splitCSVLine(line) {
      const out = []; let cur = "", inQ = false;
      for (let i = 0; i < line.length; i++) { const ch = line[i];
        if (ch === '"') { inQ = !inQ; continue; }
        if (ch === "," && !inQ) { out.push(cur); cur = ""; continue; }
        cur += ch;
      }
      out.push(cur);
      return out.map((s) => s.trim());
    }
    function toCSV(rows) {
      if (!rows?.length) return "";
      const header = Object.keys(rows[0]);
      const esc = (v) => (v == null ? "" : String(v).includes(",") ? '"' + String(v).replaceAll('"','\\"') + '"' : String(v));
      const body = rows.map((r) => header.map((h) => esc(r[h])).join(","));
      return [header.join(","), ...body].join("\n");
    }

    // ---------- Binance REST ----------
    const ENDPOINTS = { spot: "https://api.binance.com/api/v3/klines", um: "https://fapi.binance.com/fapi/v1/klines" };
    async function fetchBinanceKlines({ symbol, interval = "15m", startTime, endTime, market = "spot", pause = 200, signal }) {
      const url = ENDPOINTS[market];
      const sym = normSymbol(symbol);
      const { val: cleanInterval, fixed } = standardizeInterval(interval);
      // Show warning if standardized
      document.getElementById("warnBadge").style.display = fixed ? "inline-block" : "none";
      const tfMs = intervalToMs(cleanInterval);
      const limit = 1000;
      let cursor = startTime || undefined;
      const cutoff = endTime || Date.now();
      const all = [];
      while (true) {
        if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
        const params = new URLSearchParams({ symbol: sym, interval: cleanInterval, limit: String(limit) });
        if (cursor) params.set("startTime", String(cursor));
        if (endTime) params.set("endTime", String(endTime));
        const res = await fetch(url + "?" + params.toString());
        if (!res.ok) throw new Error("Binance API error " + res.status);
        const batch = await res.json();
        if (!Array.isArray(batch) || batch.length === 0) break;
        for (const k of batch) {
          all.push({ timestamp: new Date(k[0]).toISOString(), open: Number(k[1]), high: Number(k[2]), low: Number(k[3]), close: Number(k[4]), volume: Number(k[5]), symbol: sym });
        }
        const lastOpen = batch[batch.length - 1][0];
        if (lastOpen + tfMs > cutoff) break;
        cursor = lastOpen + tfMs;
        await sleep(pause);
      }
      return all;
    }

    // ---------- Backtest core ----------
    function normalizeTPs(direction, tps) {
      const clean = (tps || []).map(Number).filter((x) => !Number.isNaN(x));
      return (direction || "").toUpperCase() === "LONG" ? clean.sort((a,b)=>a-b) : clean.sort((a,b)=>b-a);
    }
    function entryFilled(bar, direction, low, high, touch) {
      const lo = bar.low, hi = bar.high;
      return touch ? (hi >= low && lo <= high) : (hi > low && lo < high);
    }
    function firstFillPrice(bar, direction, low, high, method) {
      const o=bar.open,h=bar.high,l=bar.low,c=bar.close;
      if (o>=low && o<=high) return o;
      if (method==="hl_order") {
        const green=c>=o; const seq = green ? [h,l] : [l,h];
        for (const v of seq){ if (v>=low && v<=high) return Math.min(Math.max(v,low),high); }
      }
      if ((direction||"").toUpperCase()==="LONG"){
        const t=(l>=low&&l<=high)?l:((h>=low&&h<=high)?h:NaN); if(!Number.isNaN(t)) return t;
      } else {
        const t=(h>=low&&h<=high)?h:((l>=low&&l<=high)?l:NaN); if(!Number.isNaN(t)) return t;
      }
      if (h>=low && l<=high) return Math.min(Math.max(o,low),high);
      throw new Error("Cannot infer fill price; no overlap");
    }
    function hitLevel(bar, direction, level, touch) {
      const lo=bar.low, hi=bar.high;
      return (direction||"").toUpperCase()==="LONG" ? (touch? hi>=level:hi>level) : (touch? lo<=level:lo<level);
    }
    function sequenceHitsInBar(bar, direction, levelsUp, levelsDown, touch, method) {
      const o=bar.open,h=bar.high,l=bar.low,c=bar.close;
      if (method==="hl_order") {
        const green=c>=o; const path = green ? [o,h,l,c] : [o,l,h,c];
        const hits=[]; let last=path[0];
        for (let i=1;i<path.length;i++) {
          const nxt=path[i]; const lo=Math.min(last,nxt), hi=Math.max(last,nxt);
          for (const L of levelsUp){ if((touch? hi>=L:hi>L) && lo<=L) hits.push({dir:"UP",level:L}); }
          for (const L of levelsDown){ if((touch? lo<=L:lo<L) && hi>=L) hits.push({dir:"DOWN",level:L}); }
          last=nxt;
        }
        return hits;
      }
      const upHit = levelsUp.some((L)=> hitLevel(bar,direction,L,touch));
      const downHit = levelsDown.some((L)=> hitLevel(bar,direction,L,touch));
      if (upHit && downHit) return [{dir: (method==="conservative" ? "DOWN":"UP"), level: (method==="conservative" ? levelsDown[0] : levelsUp[0])}];
      if (upHit) return [{dir:"UP", level: levelsUp[0]}];
      if (downHit) return [{dir:"DOWN", level: levelsDown[0]}];
      return [];
    }

    function evaluateSignal(sig, kdf, cfg){
      const rows = kdf.filter((r)=> r.symbol===sig.symbol && new Date(r.timestamp) >= new Date(sig.signal_time));
      if (!rows.length) return { signal_id: sig.signal_id, status: "NO_DATA_AFTER_SIGNAL" };
      let fillIdx=null, fillPrice=null;
      for (let i=0;i<rows.length;i++){
        const bar=rows[i];
        if (entryFilled(bar, sig.direction, sig.entry_low, sig.entry_high, cfg.touch_is_fill)) {
          fillIdx=i; try { fillPrice = firstFillPrice(bar, sig.direction, sig.entry_low, sig.entry_high, cfg.conflict_resolution); } catch { fillPrice = (sig.entry_low + sig.entry_high)/2; }
          break;
        }
      }
      if (fillIdx===null) return { signal_id: sig.signal_id, status: "NOT_FILLED", entry_range: [sig.entry_low,sig.entry_high] };

      const post = rows.slice(fillIdx);
      const dir = (sig.direction || "").toUpperCase();
      const tps = normalizeTPs(dir, sig.tps);

      let exitIdx=null, tpHit=null, slHit=null;
      const tpTouchedBeforeExit = [];
      for (let i=0;i<post.length;i++){
        const bar=post[i];
        const ups = dir==="LONG" ? tps.filter((L)=> L>=fillPrice) : tps.filter((L)=> L<=fillPrice);
        const downs = dir==="LONG" ? (sig.sl<fillPrice ? [sig.sl] : []) : (sig.sl>fillPrice ? [sig.sl] : []);
        const hits = sequenceHitsInBar(bar, dir, ups, downs, cfg.touch_is_fill, cfg.conflict_resolution);
        if (hits.length) {
          for (const h of hits) {
            if (h.dir === "UP") tpTouchedBeforeExit.push(h.level);
            if (h.dir === "DOWN") { slHit = h.level; exitIdx = i; break; }
          }
          if (exitIdx !== null) break;
          tpHit = hits.find(h=>h.dir==="UP")?.level ?? tpHit;
          if (tpHit != null) { exitIdx = i; break; }
        }
      }

      const endSlice = exitIdx!==null ? post.slice(0, exitIdx+1) : post;
      const highs = endSlice.map((b)=> b.high), lows = endSlice.map((b)=> b.low);
      const bestPrice = dir==="LONG" ? Math.max(...highs) : Math.min(...lows);
      const worstPrice = dir==="LONG" ? Math.min(...lows) : Math.max(...highs);
      const rawMFE = dir==="LONG" ? (bestPrice - fillPrice)/fillPrice : (fillPrice - bestPrice)/fillPrice;
      const rawMAE = dir==="LONG" ? (worstPrice - fillPrice)/fillPrice : (fillPrice - worstPrice)/fillPrice;
      const leveragedMFE = rawMFE * sig.leverage;
      const leveragedMAE = rawMAE * sig.leverage;

      let bestTP = null, bestTPYieldRaw = null, bestTPYieldLev = null;
      if (tps.length) {
        if (slHit != null) {
          if (tpTouchedBeforeExit.length) bestTP = dir==="LONG" ? Math.max(...tpTouchedBeforeExit) : Math.min(...tpTouchedBeforeExit);
        } else {
          if (tpHit != null) bestTP = tpHit;
          else bestTP = dir==="LONG" ? (tps.filter(tp=> bestPrice>=tp).pop() ?? null) : (tps.filter(tp=> bestPrice<=tp).pop() ?? null);
        }
        if (bestTP != null) {
          bestTPYieldRaw = dir==="LONG" ? (bestTP - fillPrice)/fillPrice : (fillPrice - bestTP)/fillPrice;
          bestTPYieldLev = bestTPYieldRaw * sig.leverage;
        }
      }

      let realizedRaw = null, realizedLev = null;
      let status;
      if (slHit != null) {
        status = "SL_HIT";
        realizedRaw = dir==="LONG" ? (slHit - fillPrice)/fillPrice : (fillPrice - slHit)/fillPrice;
        realizedLev = realizedRaw * sig.leverage;
      } else if (tpHit != null) {
        status = "TP_HIT";
        realizedRaw = dir==="LONG" ? (tpHit - fillPrice)/fillPrice : (fillPrice - tpHit)/fillPrice;
        realizedLev = realizedRaw * sig.leverage;
      } else {
        status = "OPEN_FILLED";
      }

      return {
        signal_id: sig.signal_id, symbol: sig.symbol, direction: dir, status,
        signal_time: new Date(sig.signal_time).toISOString(),
        fill_time: new Date(post[0].timestamp).toISOString(),
        fill_price: Number(fillPrice),
        entry_range: [sig.entry_low, sig.entry_high].join("-"),
        leverage: Number(sig.leverage),
        tp_hit: tpHit, sl_hit: slHit,
        best_tp_reached: bestTP,
        max_floating_raw_pct: rawMFE, max_floating_pnl_pct: leveragedMFE,
        max_drawdown_raw_pct: rawMAE, max_drawdown_pct: leveragedMAE,
        best_tp_yield_raw_pct: bestTPYieldRaw,
        best_tp_yield_pct: bestTPYieldLev,
        realized_raw_pct: realizedRaw,
        realized_pct: realizedLev,
        exit_time: (exitIdx!==null ? new Date(post[exitIdx].timestamp).toISOString() : ""),
        last_timestamp: new Date(endSlice[endSlice.length - 1].timestamp).toISOString(),
      };
    }

    // ---------- Multi-symbol orchestration ----------
    const $ = (id) => document.getElementById(id);
    const el = { autoInfer:$("autoInfer"),
      symbol:$("symbol"), market:$("market"), intervalInput:$("intervalInput"), since:$("since"), until:$("until"),
      btnFetch:$("btnFetch"), btnOneClick:$("btnOneClick"), fetchedCount:$("fetchedCount"), symBadge:$("symBadge"),
      signalsCSV:$("signalsCSV"), fileSignals:$("fileSignals"), conflict:$("conflict"), touch:$("touch"), btnRun:$("btnRun"),
      statTotal:$("statTotal"), statFilled:$("statFilled"), statHitRate:$("statHitRate"), statMaxLev:$("statMaxLev"),
      tbody:$("tbody"), btnExport:$("btnExport"), manualBox:$("manualBox")
    };
    let KLINES = []; let RESULTS = [];

    function setBusy(b){ el.btnFetch.disabled=b; el.btnOneClick.disabled=b; el.btnRun.disabled=b; }
    function parseSignalsCSV(){
      const rows = parseCSV(el.signalsCSV.value);
      return rows.map((r,i)=> ({ signal_id: r.signal_id || ("sig_"+i), symbol: (r.symbol || el.symbol.value).toUpperCase().replace("/",""),
        direction: (r.direction || "LONG").toUpperCase(), leverage: Number(r.leverage || 1),
        entry_low: Number(r.entry_low), entry_high: Number(r.entry_high), sl: Number(r.sl),
        tps: [r.tp1,r.tp2,r.tp3,r.tp4,r.tp5].filter((x)=> x !== undefined), signal_time: r.signal_time }));
    }
    function inferSymbolsAndSince(sigs){
      const symbols = Array.from(new Set(sigs.map(s=> s.symbol))).filter(Boolean);
      const times = sigs.map(s=> +new Date(s.signal_time)).filter(t=> !Number.isNaN(t));
      const earliest = times.length ? Math.min(...times) : null;
      return { symbols, sinceMs: earliest };
    }

    async function fetchAllKlines({ auto, sigs, market, interval, since, until }){
      const { val: stdInterval } = standardizeInterval(interval);
      let list = [];
      if (auto) {
        const inf = inferSymbolsAndSince(sigs);
        const syms = inf.symbols.length ? inf.symbols : [normSymbol(el.symbol.value)];
        const tfMs = intervalToMs(stdInterval);
        const sinceMs = (inf.sinceMs != null) ? (inf.sinceMs - 2 * tfMs) : (el.since.value ? toMs(el.since.value) : undefined);
        el.symBadge.textContent = syms.join(", ");
        for (const sym of syms) {
          const data = await fetchBinanceKlines({ symbol: sym, interval: stdInterval, startTime: sinceMs, endTime: (el.until.value? toMs(el.until.value): undefined), market });
          list = list.concat(data);
          await sleep(150);
        }
      } else {
        el.symBadge.textContent = normSymbol(el.symbol.value);
        const data = await fetchBinanceKlines({ symbol: el.symbol.value.trim(), interval: stdInterval, startTime: (since? toMs(since): undefined), endTime: (until? toMs(until): undefined), market });
        list = data;
      }
      return list.sort((a,b)=> (a.symbol===b.symbol) ? (new Date(a.timestamp)-new Date(b.timestamp)) : a.symbol.localeCompare(b.symbol));
    }

    async function handleFetch(){
      try {
        setBusy(true); RESULTS = []; renderResults();
        const sigs = parseSignalsCSV();
        KLINES = await fetchAllKlines({ auto: el.autoInfer.checked, sigs, market: el.market.value, interval: el.intervalInput.value, since: el.since.value, until: el.until.value });
        el.fetchedCount.textContent = "已获取：" + KLINES.length + " 根";
      } catch (e) { alert("拉取出错：" + e.message); } finally { setBusy(false); }
    }
    function runBacktest(usingKlines){
      const cfg = { conflict_resolution: el.conflict.value, touch_is_fill: el.touch.value === "true" };
      const sigs = parseSignalsCSV(); RESULTS = sigs.map((sig)=> evaluateSignal(sig, usingKlines, cfg)); renderResults();
    }
    async function handleOneClick(){
      try {
        setBusy(true); RESULTS = []; renderResults();
        const sigs = parseSignalsCSV();
        KLINES = await fetchAllKlines({ auto: el.autoInfer.checked, sigs, market: el.market.value, interval: el.intervalInput.value, since: el.since.value, until: el.until.value });
        el.fetchedCount.textContent = "已获取：" + KLINES.length + " 根";
        runBacktest(KLINES);
      } catch (e) { alert("一键回测出错：" + e.message); } finally { setBusy(false); }
    }

    function renderResults(){
      el.manualBox.style.opacity = el.autoInfer.checked ? ".5" : "1";
      el.manualBox.classList.toggle("hidden", el.autoInfer.checked);
      document.getElementById("warnBadge").style.display = "none";

      el.statTotal.textContent = String(RESULTS.length);
      const filled = RESULTS.filter((r)=> r.status !== "NOT_FILLED" && r.status !== "NO_DATA_AFTER_SIGNAL");
      el.statFilled.textContent = String(filled.length);
      const hitRate = filled.length ? (filled.filter((r)=> r.status === "TP_HIT").length / filled.length) : null;
      el.statHitRate.textContent = hitRate == null ? "-" : (hitRate * 100).toFixed(2) + "%";
      const maxLev = filled.length ? Math.max.apply(null, filled.map((r)=> Number(r.max_floating_pnl_pct ?? -Infinity))) : -Infinity;
      el.statMaxLev.textContent = maxLev === -Infinity ? "-" : (maxLev * 100).toFixed(2) + "%";

      const cols = ["signal_id","symbol","direction","status","fill_price","tp_hit","sl_hit","best_tp_reached","max_floating_raw_pct","max_floating_pnl_pct","max_drawdown_raw_pct","max_drawdown_pct","best_tp_yield_raw_pct","best_tp_yield_pct","realized_raw_pct","realized_pct","fill_time","exit_time","last_timestamp"];
      el.tbody.innerHTML = "";
      for (const r of RESULTS) {
        const tr = document.createElement("tr");
        for (const c of cols) {
          const td = document.createElement("td");
          let v = r[c];
          if (c==="fill_price") v = fmtNum(v);
          if (c.includes("_pct")) v = fmtPct(v);
          if (v == null || v === "") v = "-";
          if (typeof v === "string" && (c.endsWith("_time") || c === "last_timestamp")) v = v.replace("T"," ").replace("Z","");
          td.textContent = v; tr.appendChild(td);
        }
        el.tbody.appendChild(tr);
      }
    }

    document.getElementById("btnFetch").addEventListener("click", handleFetch);
    document.getElementById("btnOneClick").addEventListener("click", handleOneClick);
    document.getElementById("btnRun").addEventListener("click", ()=> runBacktest(KLINES));
    document.getElementById("fileSignals").addEventListener("change", (e)=>{ const f = e.target.files?.[0]; if (!f) return; const rdr = new FileReader(); rdr.onload = ()=> { document.getElementById("signalsCSV").value = String(rdr.result || ""); renderResults(); }; rdr.readAsText(f); });
    document.getElementById("autoInfer").addEventListener("change", renderResults);

    renderResults();
  </script>
</body>
</html>
