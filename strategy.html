<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>策略图片生成器</title>
  <style>
      * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
      }
      
      body {
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          padding: 20px;
          min-height: 100vh;
      }
      
      .container {
          max-width: 1400px;
          margin: 0 auto;
          display: grid;
          grid-template-columns: 450px 1fr;
          gap: 20px;
      }
      
      .panel {
          background: white;
          border-radius: 12px;
          padding: 25px;
          box-shadow: 0 10px 40px rgba(0,0,0,0.1);
      }
      
      h2 {
          color: #333;
          margin-bottom: 20px;
          font-size: 20px;
          border-bottom: 2px solid #667eea;
          padding-bottom: 10px;
      }
      
      .form-group {
          margin-bottom: 15px;
      }
      
      label {
          display: block;
          margin-bottom: 5px;
          color: #555;
          font-weight: 600;
          font-size: 13px;
      }
      
      input, select {
          width: 100%;
          padding: 10px;
          border: 2px solid #e0e0e0;
          border-radius: 6px;
          font-size: 14px;
          transition: border-color 0.3s;
      }
      
      input:focus, select:focus {
          outline: none;
          border-color: #667eea;
      }
      
      .row {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 10px;
      }
      
      .color-input-group {
          display: flex;
          gap: 8px;
          align-items: center;
      }
      
      .color-btn {
          padding: 8px 12px;
          margin: 0;
          height: 38px;
          width: auto;
          font-size: 13px;
          background: #667eea;
      }
      
      input[type="color"] {
          width: 50px;
          height: 38px;
          border: none;
          cursor: pointer;
      }
      
      input[type="file"] {
          padding: 8px;
      }
      
      button {
          width: 100%;
          padding: 12px;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border: none;
          border-radius: 6px;
          font-size: 15px;
          font-weight: 600;
          cursor: pointer;
          transition: transform 0.2s;
          margin-top: 10px;
      }
      
      button:hover {
          transform: translateY(-2px);
      }
      
      button:active {
          transform: translateY(0);
      }
      
      .preview-section {
          display: flex;
          flex-direction: column;
          align-items: center;
      }
      
      #canvas {
          border: 2px solid #e0e0e0;
          border-radius: 8px;
          max-width: 100%;
          box-shadow: 0 5px 20px rgba(0,0,0,0.1);
      }
      
      .download-btn {
          margin-top: 15px;
          background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      }
      
      .style-section {
          background: #f8f9fa;
          padding: 15px;
          border-radius: 8px;
          margin-bottom: 15px;
      }
      
      .style-section h3 {
          font-size: 14px;
          color: #667eea;
          margin-bottom: 12px;
      }
      
      .quick-colors {
          display: flex;
          gap: 8px;
          margin-top: 8px;
      }
      
      .quick-color {
          width: 30px;
          height: 30px;
          border-radius: 4px;
          cursor: pointer;
          border: 2px solid transparent;
          transition: all 0.2s;
      }
      
      .quick-color:hover {
          border-color: #667eea;
          transform: scale(1.1);
      }

      /* 头图历史缩略图 */
      .header-history {
          display: flex;
          gap: 8px;
          margin-top: 10px;
          align-items: center;
      }

      .header-thumb {
          width: 100px;
          height: 70px;
          object-fit: cover;
          border-radius: 8px;
          cursor: pointer;
          border: 2px solid transparent;
          box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      }

      .header-thumb.selected {
          border-color: #667eea;
      }
  </style>
</head>
<body>
  <div class="container">
      <!-- 左侧输入面板 -->
      <div class="panel">
          <h2>📊 策略参数输入</h2>
          
          <div class="form-group">
              <label>策略编号</label>
              <input type="text" id="strategy_id" value="209898" placeholder="例如: 209898">
          </div>
          
          <div class="form-group">
              <label>交易标的</label>
              <div style="display: flex; gap: 8px;">
                  <select id="symbol_name" style="flex: 1;">
                      <option value="BTC">BTC</option>
                      <option value="ETH">ETH</option>
                  </select>
              </div>
          </div>
          
          <div class="form-group">
              <label>操作方向</label>
              <select id="direction">
                  <option value="long">LONG (多)</option>
                  <option value="short">SHORT (空)</option>
              </select>
          </div>
          
          <div class="form-group">
              <label>基础进场价</label>
              <input type="number" id="entry_price" value="110947" placeholder="例如: 110947">
          </div>
          
          <div class="form-group">
              <label>生成图片语言</label>
              <select id="language">
                  <option value="en">英语</option>
                  <option value="ru">俄语</option>
                  <option value="vi">越南语</option>
                  <option value="ar">阿拉伯语</option>
              </select>
          </div>
          
          <div class="style-section">
              <h3>🎨 图片样式设置</h3>
              
              <div class="row">
                  <div class="form-group">
                      <label>字体大小</label>
                      <input type="number" id="fontSize" value="25" min="12" max="36">
                  </div>
                  <div class="form-group">
                      <label>图片分辨率倍数</label>
                      <input type="number" id="exportScale" value="2" min="1" max="5" step="0.5">
                  </div>
              </div>
              
              <div class="form-group">
                  <label>文字颜色</label>
                  <div class="color-input-group">
                      <input type="color" id="textColor" value="#ffffff">
                      <input type="text" id="textColorHex" value="#ffffff" placeholder="#ffffff">
                      <button class="color-btn" onclick="applyColor('text')">确定</button>
                  </div>
                  <div class="quick-colors">
                      <div class="quick-color" style="background: #ffffff" onclick="setColor('text', '#ffffff')"></div>
                      <div class="quick-color" style="background: #000000" onclick="setColor('text', '#000000')"></div>
                      <div class="quick-color" style="background: #667eea" onclick="setColor('text', '#667eea')"></div>
                      <div class="quick-color" style="background: #38ef7d" onclick="setColor('text', '#38ef7d')"></div>
                      <div class="quick-color" style="background: #ffd700" onclick="setColor('text', '#ffd700')"></div>
                  </div>
              </div>
              
              <div class="form-group">
                  <label>文字背景颜色</label>
                  <div class="color-input-group">
                      <input type="color" id="textBgColor" value="#1a1a2e">
                      <input type="text" id="textBgColorHex" value="#1a1a2e" placeholder="#1a1a2e">
                      <button class="color-btn" onclick="applyColor('textBg')">确定</button>
                  </div>
                  <div class="quick-colors">
                      <div class="quick-color" style="background: #1a1a2e" onclick="setColor('textBg', '#1a1a2e')"></div>
                      <div class="quick-color" style="background: #2d3436" onclick="setColor('textBg', '#2d3436')"></div>
                      <div class="quick-color" style="background: #0f3460" onclick="setColor('textBg', '#0f3460')"></div>
                      <div class="quick-color" style="background: rgba(0,0,0,0.7)" onclick="setColor('textBg', 'rgba(0,0,0,0.7)')"></div>
                  </div>
              </div>
              
              <div class="row">
                  <div class="form-group">
                      <label>背景圆角</label>
                      <input type="number" id="bgRadius" value="15" min="0" max="50">
                  </div>
                  <div class="form-group">
                      <label>背景透明度</label>
                      <input type="number" id="bgOpacity" value="1" min="0" max="1" step="0.1">
                  </div>
              </div>
          </div>
          
          <div class="form-group">
              <label>上传头图</label>
              <input type="file" id="headerImage" accept="image/*">
              <div style="font-size:12px;color:#666;margin-top:8px;">最近头图（最多 4 条，点击可恢复）</div>
              <div id="headerHistory" class="header-history" aria-live="polite"></div>
          </div>
          
          <button onclick="generateImage()">🎨 生成策略图片</button>
      </div>
      
      <!-- 右侧预览面板 -->
      <div class="panel preview-section">
          <h2>🖼️ 图片预览</h2>
          <canvas id="canvas" width="800" height="1000"></canvas>
          <button class="download-btn" onclick="downloadImage()">⬇️ 下载图片</button>
      </div>
  </div>

  <script>
      // 语言模板
      const templates = {
          en: {
              title: "✅ Strategy ID {strategy_id}",
              lines: [
                  "{symbol_name} (Total Position {total_position_pct}%)",
                  "Entry Range: {price_low} – {price_high}",
                  "Direction: {direction}",
                  "Max Position Size: {total_position_pct}%",
                  "Leverage: {leverage}x",
                  "Partial Take-Profit Prices: {tp1} / {tp2} / {tp3}",
                  "Stop Loss: {sl}"
              ],
              align: "left",
              font: "Arial, sans-serif"
              ,directionLabels: { long: 'Long', short: 'Short' }
          },
          ru: {
              title: "✅ Стратегия №{strategy_id}",
              lines: [
                  "{symbol_name} (Общий объём позиции {total_position_pct}%)",
                  "Диапазон входа: {price_low} – {price_high}",
                  "Направление: {direction}",
                  "Максимальный размер позиции: {total_position_pct}%",
                  "Плечо: {leverage}x",
                  "Цены частичной фиксации прибыли: {tp1} / {tp2} / {tp3}",
                  "Стоп-лосс: {sl}"
              ],
              align: "left",
              font: "Arial, sans-serif"
              ,directionLabels: { long: 'Длинная', short: 'Короткая' }
          },
          vi: {
              title: "✅ Chiến lược số {strategy_id}",
              lines: [
                  "{symbol_name} (Tổng vị thế {total_position_pct}%)",
                  "Vùng vào lệnh: {price_low} – {price_high}",
                  "Hướng giao dịch: {direction}",
                  "Giới hạn vị thế: {total_position_pct}%",
                  "Đòn bẩy: {leverage}x",
                  "Giá chốt lời từng phần: {tp1} / {tp2} / {tp3}",
                  "Cắt lỗ: {sl}"
              ],
              align: "left",
              font: "Arial, sans-serif"
              ,directionLabels: { long: 'Mua (Long)', short: 'Bán (Short)' }
          },
          ar: {
              title: "✅ رقم الإستراتيجية {strategy_id}",
              lines: [
                  "{symbol_name} (إجمالي حجم الصفقة {total_position_pct}%)",
                  "نطاق الدخول: {price_low} – {price_high}",
                  "الاتجاه: {direction}",
                  "الحد الأقصى لحجم الصفقة: {total_position_pct}%",
                  "الرافعة المالية: {leverage}x",
                  "أسعار جني الأرباح الجزئية: {tp1} / {tp2} / {tp3}",
                  "إيقاف الخسارة: {sl}"
              ],
              align: "right",
              font: "Arial, sans-serif"
              ,directionLabels: { long: 'شراء', short: 'بيع' }
          }
      };

      let headerImageData = null;

      // 计算策略参数
      function calculateStrategy(symbolName, entryPrice, direction) {
          const symbol = symbolName.toUpperCase();
          const offset = symbol.includes('BTC') ? 100 : 10;
          
          // 判断是多单还是空单
          const isLong = direction === 'long';
          
          return {
              price_low: Math.round(entryPrice - offset),    // BTC: entry_price-100, ETH: entry_price-10
              price_high: Math.round(entryPrice + offset),   // BTC: entry_price+100, ETH: entry_price+10
              leverage: 100,                                 // 固定值
              total_position_pct: 5,                         // 固定值
              // 多单：向上止盈，向下止损
              // 空单：向下止盈，向上止损
              tp1: isLong ? 
                  Math.round(entryPrice * (1 + 0.012)) :    // 多单：entry_price × (1+0.012)
                  Math.round(entryPrice * (1 - 0.012)),     // 空单：entry_price × (1-0.012)
              tp2: isLong ? 
                  Math.round(entryPrice * (1 + 0.018)) :    // 多单：entry_price × (1+0.018)
                  Math.round(entryPrice * (1 - 0.018)),     // 空单：entry_price × (1-0.018)
              tp3: isLong ? 
                  Math.round(entryPrice * (1 + 0.03)) :     // 多单：entry_price × (1+0.03)
                  Math.round(entryPrice * (1 - 0.03)),      // 空单：entry_price × (1-0.03)
              sl: isLong ? 
                  Math.round(entryPrice * (1 - 0.01)) :     // 多单：entry_price × (1-0.01)
                  Math.round(entryPrice * (1 + 0.01))       // 空单：entry_price × (1+0.01)
          };
      }

      // 颜色选择器同步与应用
      document.getElementById('textColor').addEventListener('input', (e) => {
          document.getElementById('textColorHex').value = e.target.value;
          generateImage(); // 颜色选择器变化时实时预览
      });
      
      document.getElementById('textBgColor').addEventListener('input', (e) => {
          document.getElementById('textBgColorHex').value = e.target.value;
          generateImage(); // 颜色选择器变化时实时预览
      });
      
      // 确认按钮应用颜色
      function applyColor(type) {
          const hexInput = document.getElementById(type === 'text' ? 'textColorHex' : 'textBgColorHex');
          const colorPicker = document.getElementById(type === 'text' ? 'textColor' : 'textBgColor');
          
          // 验证颜色格式
          const colorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
          let color = hexInput.value.trim();
          
          // 如果没有#号，添加#号
          if (!color.startsWith('#')) {
              color = '#' + color;
          }
          
          // 验证颜色值
          if (colorRegex.test(color)) {
              colorPicker.value = color;
              hexInput.value = color;
              generateImage(); // 应用新颜色并重新生成图片
              // 只有在用户点击【确定】时，才把当前颜色保存到对应的历史记录
              try {
                  if (type === 'text') {
                      saveTextColor();
                  } else {
                      saveBgColor();
                  }
              } catch (e) {
                  // 忽略保存错误，仍然保持预览更新
                  console.warn('保存颜色失败', e);
              }
          } else {
              alert('请输入有效的颜色值，例如: #FF0000');
              // 恢复为颜色选择器的当前值
              hexInput.value = colorPicker.value;
          }
      }

      // 当语言改变时，更新 direction 选项文本为对应语言
      function updateDirectionLabels() {
          const lang = document.getElementById('language').value;
          const tpl = templates[lang] || templates['en'];
          const labels = tpl.directionLabels || { long: 'Long', short: 'Short' };
          const sel = document.getElementById('direction');
          // 保留当前选中值
          const current = sel.value;
          sel.innerHTML = '';
          const optLong = document.createElement('option');
          optLong.value = 'long';
          optLong.textContent = labels.long;
          const optShort = document.createElement('option');
          optShort.value = 'short';
          optShort.textContent = labels.short;
          sel.appendChild(optLong);
          sel.appendChild(optShort);
          // 恢复之前的选择（若仍可用）
          if (current === 'long' || current === 'short') sel.value = current;
      }

      document.getElementById('language').addEventListener('change', () => {
          updateDirectionLabels();
      });

      // 快速颜色选择
      function setColor(type, color) {
          if (type === 'text') {
              document.getElementById('textColor').value = color;
              document.getElementById('textColorHex').value = color;
          } else {
              document.getElementById('textBgColor').value = color;
              document.getElementById('textBgColorHex').value = color;
          }
          // 仅刷新预览，不保存历史（用户需点击“确定”来保存）
          generateImage();
      }

      // 上传头图
      // 保存配置到本地存储
      function saveConfig() {
          const config = {
              strategy_id: document.getElementById('strategy_id').value,
              symbol_name: document.getElementById('symbol_name').value,
              direction: document.getElementById('direction').value,
              entry_price: document.getElementById('entry_price').value,
              language: document.getElementById('language').value,
              fontSize: document.getElementById('fontSize').value,
              exportScale: document.getElementById('exportScale').value
          };
          localStorage.setItem('lastConfig', JSON.stringify(config));
      }

      // 加载上次的配置
      function loadLastConfig() {
          const lastConfig = localStorage.getItem('lastConfig');
          if (lastConfig) {
              const config = JSON.parse(lastConfig);
              Object.entries(config).forEach(([key, value]) => {
                  const element = document.getElementById(key);
                  if (element) {
                      element.value = value;
                  }
              });
          }
      }

      // 颜色记录管理
      const MAX_COLOR_HISTORY = 4;
      
      function loadSavedColors() {
          // 加载文字颜色和背景颜色的独立历史记录
          const textHistory = JSON.parse(localStorage.getItem('textColorHistory') || '[]');
          const bgHistory = JSON.parse(localStorage.getItem('bgColorHistory') || '[]');

          if (textHistory.length > 0) {
              document.getElementById('textColor').value = textHistory[0];
              document.getElementById('textColorHex').value = textHistory[0];
          }
          if (bgHistory.length > 0) {
              document.getElementById('textBgColor').value = bgHistory[0];
              document.getElementById('textBgColorHex').value = bgHistory[0];
          }

          // 创建两组历史按钮
          createColorHistoryButtons('text', textHistory);
          createColorHistoryButtons('bg', bgHistory);
      }

      // 创建颜色历史按钮（type = 'text' 或 'bg'）
      function createColorHistoryButtons(type, history) {
          const selector = type === 'text' ? '.form-group:has(#textColor) .quick-colors' : '.form-group:has(#textBgColor) .quick-colors';
          const container = document.querySelector(selector);
          if (!container) return;

          container.innerHTML = '';

          history.slice(0, MAX_COLOR_HISTORY).forEach((color, index) => {
              const btn = document.createElement('div');
              btn.className = 'quick-color';
              btn.style.background = color;
              btn.title = `历史颜色 ${index + 1}`;
              btn.dataset.color = color;
              btn.onclick = () => {
                  if (type === 'text') {
                      document.getElementById('textColor').value = color;
                      document.getElementById('textColorHex').value = color;
                  } else {
                      document.getElementById('textBgColor').value = color;
                      document.getElementById('textBgColorHex').value = color;
                  }
                  generateImage();
              };
              container.appendChild(btn);
          });
      }

      // 保存文字颜色历史
      function saveTextColor() {
          const color = document.getElementById('textColor').value.toLowerCase();
          let history = JSON.parse(localStorage.getItem('textColorHistory') || '[]');
          history = history.filter(c => c.toLowerCase() !== color);
          history.unshift(color);
          history = history.slice(0, MAX_COLOR_HISTORY);
          localStorage.setItem('textColorHistory', JSON.stringify(history));
          createColorHistoryButtons('text', history);
      }

      // 保存背景颜色历史
      function saveBgColor() {
          const color = document.getElementById('textBgColor').value.toLowerCase();
          let history = JSON.parse(localStorage.getItem('bgColorHistory') || '[]');
          history = history.filter(c => c.toLowerCase() !== color);
          history.unshift(color);
          history = history.slice(0, MAX_COLOR_HISTORY);
          localStorage.setItem('bgColorHistory', JSON.stringify(history));
          createColorHistoryButtons('bg', history);
      }

      // 保存最后使用的头图
      function saveLastHeaderImage(file) {
          return new Promise((resolve, reject) => {
              try {
                  const reader = new FileReader();
                  reader.onload = (event) => {
                      // 创建一个临时图片来获取图片尺寸
                      const img = new Image();
                      img.onload = () => {
                          // 创建canvas来压缩图片
                          const canvas = document.createElement('canvas');
                          const ctx = canvas.getContext('2d');
                          
                          // 计算压缩后的尺寸，保持宽高比
                          let width = img.width;
                          let height = img.height;
                          const MAX_WIDTH = 1200; // 最大宽度
                          
                          if (width > MAX_WIDTH) {
                              height = Math.round(height * (MAX_WIDTH / width));
                              width = MAX_WIDTH;
                          }
                          
                          canvas.width = width;
                          canvas.height = height;
                          
                          // 绘制并压缩图片
                          ctx.drawImage(img, 0, 0, width, height);
                          
                          // 转换为较小的JPEG格式
                          const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                          
                          // 保存压缩后的图片数据
                          // 持久化为最近一次，并加入历史
                          localStorage.setItem('lastHeaderImage', compressedDataUrl);
                          localStorage.setItem('headerImageTimestamp', Date.now());
                          // 将图片加入历史（recent 4）
                          try {
                              saveHeaderHistory(compressedDataUrl);
                          } catch (e) {
                              console.warn('保存头图历史失败', e);
                          }
                          resolve(compressedDataUrl);
                      };
                      img.onerror = reject;
                      img.src = event.target.result;
                  };
                  reader.onerror = reject;
                  reader.readAsDataURL(file);
              } catch (error) {
                  reject(error);
              }
          });
      }

      // 保存头图到历史（最多保留 4 条），dataUrl 必须是压缩后的 DataURL
      function saveHeaderHistory(dataUrl) {
          if (!dataUrl) return;
          let history = JSON.parse(localStorage.getItem('headerImageHistory') || '[]');
          // 去重：若已存在则移除旧项
          history = history.filter(item => item !== dataUrl);
          history.unshift(dataUrl);
          history = history.slice(0, 4);
          localStorage.setItem('headerImageHistory', JSON.stringify(history));
          renderHeaderHistory();
      }

      // 渲染头图历史缩略图
      function renderHeaderHistory() {
          const container = document.getElementById('headerHistory');
          if (!container) return;
          const history = JSON.parse(localStorage.getItem('headerImageHistory') || '[]');
          container.innerHTML = '';
          history.forEach((dataUrl, idx) => {
              const img = document.createElement('img');
              img.src = dataUrl;
              img.className = 'header-thumb';
              img.title = `最近头图 ${idx + 1}`;
              img.addEventListener('click', () => {
                  // 点击缩略图恢复为当前头图并持久化为 lastHeaderImage
                  const restoreImg = new Image();
                  restoreImg.onload = () => {
                      headerImageData = restoreImg;
                      // 将所选缩略图设为 lastHeaderImage
                      localStorage.setItem('lastHeaderImage', dataUrl);
                      localStorage.setItem('headerImageTimestamp', Date.now());
                      // 更新缩略选中样式
                      Array.from(container.children).forEach(c => c.classList.remove('selected'));
                      img.classList.add('selected');
                      generateImage();
                  };
                  restoreImg.src = dataUrl;
              });
              container.appendChild(img);
          });
      }

      function loadLastHeaderImage() {
          const lastImageData = localStorage.getItem('lastHeaderImage');
          const timestamp = localStorage.getItem('headerImageTimestamp');
          
          if (lastImageData && timestamp) {
              // 检查图片是否是在最近24小时内保存的
              const isRecent = (Date.now() - parseInt(timestamp)) < (24 * 60 * 60 * 1000);
              
              if (isRecent) {
                  const img = new Image();
                  img.onload = () => {
                      headerImageData = img;
                      generateImage();
                  };
                  img.src = lastImageData;
              } else {
                  // 如果图片太旧，清除存储
                  localStorage.removeItem('lastHeaderImage');
                  localStorage.removeItem('headerImageTimestamp');
              }
          }
      }

      // 加载头图历史并渲染（供初始化使用）
      function loadHeaderHistory() {
          renderHeaderHistory();
          // 如果 lastHeaderImage 不存在但历史存在，则使用历史第一项作为 last
          const last = localStorage.getItem('lastHeaderImage');
          const history = JSON.parse(localStorage.getItem('headerImageHistory') || '[]');
          if (!last && history.length > 0) {
              localStorage.setItem('lastHeaderImage', history[0]);
              localStorage.setItem('headerImageTimestamp', Date.now());
          }
      }

      // 颜色变化时仅更新预览（不要在滑动/输入时记录历史）
      document.getElementById('textColor').addEventListener('input', () => {
          generateImage();
      });
      document.getElementById('textBgColor').addEventListener('input', () => {
          generateImage();
      });

      // 配置变化时保存
      ['strategy_id', 'symbol_name', 'direction', 'entry_price', 'language', 'fontSize', 'exportScale'].forEach(id => {
          document.getElementById(id).addEventListener('change', saveConfig);
      });

      document.getElementById('headerImage').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (file) {
              try {
                  // 保存并获取压缩后的图片数据
                  const compressedDataUrl = await saveLastHeaderImage(file);
                  
                  // 加载压缩后的图片到预览
                  const img = new Image();
                  img.onload = () => {
                      headerImageData = img;
                      generateImage();
                  };
                  img.src = compressedDataUrl;
              } catch (error) {
                  console.error('Error processing image:', error);
                  alert('图片处理失败，请尝试使用较小的图片');
              }
          }
      });

      // 生成图片（可选：传入 targetCanvas 与 scale 以生成更高清的导出画布）
      function generateImage(targetCanvas = null, scale = 1) {
          const canvas = targetCanvas || document.getElementById('canvas');

          // 获取输入值
          const strategyId = document.getElementById('strategy_id').value;
          const symbolName = document.getElementById('symbol_name').value;
          const direction = document.getElementById('direction').value;
          const entryPrice = parseFloat(document.getElementById('entry_price').value);
          const language = document.getElementById('language').value;
          
          // 样式参数
          const fontSize = parseInt(document.getElementById('fontSize').value);
          const textColor = document.getElementById('textColor').value;
          const textBgColor = document.getElementById('textBgColor').value;
          const bgRadius = parseInt(document.getElementById('bgRadius').value);
          const bgOpacity = parseFloat(document.getElementById('bgOpacity').value);

          // 计算策略参数
          const calculated = calculateStrategy(symbolName, entryPrice, direction);
          
          // 准备数据
          const data = {
              strategy_id: strategyId,
              symbol_name: symbolName,
              direction: direction,
              entry_price: entryPrice,
              ...calculated
          };
          
          // 获取模板
          const template = templates[language] || templates['en'];

          // 将 direction 内部值映射为模板语言的显示文本（long/short -> 本地化字符串）
          const dirValue = document.getElementById('direction').value; // 'long' or 'short'
          const localizedDirection = (template.directionLabels && template.directionLabels[dirValue]) ? template.directionLabels[dirValue] : (dirValue === 'long' ? 'Long' : 'Short');
          
          // 把本地化 direction 放入 data 中，这样模板替换 {direction} 时会使用正确语言
          data.direction = localizedDirection;

          // 先计算需要的高度（不改变现有 canvas 内容）
          const scaleFactor = scale || 1;
          const paddingScaled = Math.round(30 * scaleFactor);
          const fontSizeScaled = Math.round(fontSize * scaleFactor);
          const titleFontScaled = Math.round((fontSize + 4) * scaleFactor);
          const lineHeight = fontSizeScaled * 1.8;
          const titleText = template && template.title ? template.title.replace(/{(\w+)}/g, (m,k) => data[k] || m) : '';
          const contentLines = template && template.lines ? template.lines.map(line => line.replace(/{(\w+)}/g, (m,k) => data[k] || m)) : [];

          const bgHeight = Math.round(lineHeight * (contentLines.length + 2) + paddingScaled * 2);

          // 头图高度预测（若有头图）
          const canvasWidth = canvas.width;
          let headerDrawHeight = 0;
          let topSpacing = 0; // 若无头图，用作顶部空白
          if (headerImageData) {
              const imgAspect = headerImageData.width / headerImageData.height;
              headerDrawHeight = Math.round(canvasWidth / imgAspect);
              topSpacing = 0;
          } else {
              headerDrawHeight = 0;
              topSpacing = Math.round(50 * scaleFactor); // 保持与之前一致的默认顶部空白，并随 scale 缩放
          }

          const bottomPadding = 40;
          const totalHeight = topSpacing + headerDrawHeight + bgHeight + bottomPadding;

          // 设置 canvas 高度（会重置画布状态），然后重新获取 ctx
          canvas.height = Math.max(totalHeight, 200);
          const ctx = canvas.getContext('2d', { alpha: false });
          
          // 针对高分辨率导出优化渲染设置
          if (scale > 1) {
              // 对于高分辨率导出，禁用平滑以实现点对点渲染
              ctx.imageSmoothingEnabled = false;
              // 设置文字渲染优化
              ctx.textRendering = "geometricPrecision";
              ctx.fontKerning = "normal";
          } else {
              // 预览时保持平滑
              ctx.imageSmoothingEnabled = true;
          }

          // 清空画布 — 使用文字背景色作为画布底色以减少半透明层叠时的色差接缝
          ctx.fillStyle = textBgColor || '#f0f0f0';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // 绘制头图（若有），并紧贴后续内容（不额外增加间隙）
          let currentY = topSpacing;
          if (headerImageData) {
              const headerWidth = canvas.width;
              const drawHeight = headerDrawHeight;
              ctx.drawImage(headerImageData, 0, 0, headerWidth, drawHeight);
              currentY += drawHeight; // 直接紧贴
          }

          // 绘制文字背景
          const bgY = Math.round(currentY);
          // 绘制圆角矩形背景
          ctx.globalAlpha = bgOpacity;
          ctx.fillStyle = textBgColor;
          const bgRadiusScaled = Math.round(bgRadius * scaleFactor);
          roundRect(ctx, paddingScaled, bgY, canvas.width - paddingScaled * 2, bgHeight, bgRadiusScaled);
          ctx.fill();
          ctx.globalAlpha = 1;

          // 设置文字样式（使用缩放后的字体尺寸）
          ctx.fillStyle = textColor;
          ctx.font = `bold ${titleFontScaled}px ${template.font}`;
          ctx.textAlign = template.align;
          
          const textX = template.align === 'right' ? canvas.width - paddingScaled - Math.round(20 * scaleFactor) : paddingScaled + Math.round(20 * scaleFactor);
          let textY = bgY + paddingScaled + fontSizeScaled + Math.round(10 * scaleFactor);

          // 绘制标题
          ctx.fillText(titleText.replace(/{(\w+)}/g, (m,k) => data[k] || m), textX, textY);

          // 绘制内容
          ctx.font = `${fontSizeScaled}px ${template.font}`;
          textY += lineHeight * 1.5;
          contentLines.forEach((line, index) => {
              // 判断是否是 Direction 行
              if (line.includes(localizedDirection)) {
                  // 保存当前状态
                  ctx.save();
                  
                  // 设置描边样式
                  ctx.strokeStyle = '#FFFFFF';  // 白色描边
                  ctx.lineWidth = Math.max(1, Math.round(3 * scaleFactor));  // 描边宽度，随分辨率缩放
                  ctx.lineJoin = 'round';      // 圆角连接
                  ctx.miterLimit = 2;          // 限制尖角
                  
                  // 根据方向设置填充颜色
                  if (direction === 'long') {
                      ctx.fillStyle = '#00DA90'; // 多头绿色
                  } else if (direction === 'short') {
                      ctx.fillStyle = '#F04343'; // 空头红色
                  }
                  
                  // 先绘制描边，再绘制文字（这样文字会在描边上层）
                  ctx.strokeText(line, textX, textY);
                  ctx.fillText(line, textX, textY);
                  
                  // 恢复之前的状态
                  ctx.restore();
              } else {
                  ctx.fillText(line, textX, textY);
              }
              textY += lineHeight;
          });
      }

      // 绘制圆角矩形
      function roundRect(ctx, x, y, width, height, radius) {
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
      }

      // 下载图片 — 以更高分辨率重新渲染原始长图（保持长图比例不变）
      function downloadImage() {
          const preview = document.getElementById('canvas');

          // 先重新生成一次预览，保证策略信息、头图和颜色等都是最新的
          generateImage();

          const baseW = preview.width;
          const baseH = preview.height;

          // 从输入框获取导出分辨率倍数
          const exportScale = parseFloat(document.getElementById('exportScale').value) || 2;

          // 创建一个用于高分辨率渲染的临时画布
          const temp = document.createElement('canvas');
          temp.width = Math.round(baseW * exportScale);
          temp.height = Math.round(baseH * exportScale);

          // 使用 generateImage 在临时画布上以 exportScale 重绘（向量方式渲染，文字更清晰）
          generateImage(temp, exportScale);

          // 导出 PNG
          const link = document.createElement('a');
          const strategyId = document.getElementById('strategy_id').value;
          link.download = `strategy_${strategyId}_x${exportScale}.png`;
          link.href = temp.toDataURL('image/png');
          link.click();
      }

      // 初始化生成
      window.onload = () => {
          loadLastConfig();     // 加载上次的配置
          loadSavedColors();    // 加载保存的颜色
          loadHeaderHistory();  // 加载头图历史并渲染
          loadLastHeaderImage(); // 加载上次使用的头图
          updateDirectionLabels();
          generateImage();
      };
  </script>
</body>
</html>