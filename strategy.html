<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç­–ç•¥å›¾ç‰‡ç”Ÿæˆå™¨</title>
  <style>
      * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
      }
      
      body {
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          padding: 20px;
          min-height: 100vh;
      }
      
      .container {
          max-width: 1400px;
          margin: 0 auto;
          display: grid;
          grid-template-columns: 450px 1fr;
          gap: 20px;
      }
      
      .panel {
          background: white;
          border-radius: 12px;
          padding: 25px;
          box-shadow: 0 10px 40px rgba(0,0,0,0.1);
      }
      
      h2 {
          color: #333;
          margin-bottom: 20px;
          font-size: 20px;
          border-bottom: 2px solid #667eea;
          padding-bottom: 10px;
      }
      
      .form-group {
          margin-bottom: 15px;
      }
      
      label {
          display: block;
          margin-bottom: 5px;
          color: #555;
          font-weight: 600;
          font-size: 13px;
      }
      
      input, select {
          width: 100%;
          padding: 10px;
          border: 2px solid #e0e0e0;
          border-radius: 6px;
          font-size: 14px;
          transition: border-color 0.3s;
      }
      
      input:focus, select:focus {
          outline: none;
          border-color: #667eea;
      }
      
      .row {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 10px;
      }
      
      .color-input-group {
          display: flex;
          gap: 8px;
          align-items: center;
      }
      
      .color-btn {
          padding: 8px 12px;
          margin: 0;
          height: 38px;
          width: auto;
          font-size: 13px;
          background: #667eea;
      }
      
      input[type="color"] {
          width: 50px;
          height: 38px;
          border: none;
          cursor: pointer;
      }
      
      input[type="file"] {
          padding: 8px;
      }
      
      button {
          width: 100%;
          padding: 12px;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border: none;
          border-radius: 6px;
          font-size: 15px;
          font-weight: 600;
          cursor: pointer;
          transition: transform 0.2s;
          margin-top: 10px;
      }
      
      button:hover {
          transform: translateY(-2px);
      }
      
      button:active {
          transform: translateY(0);
      }
      
      .preview-section {
          display: flex;
          flex-direction: column;
          align-items: center;
      }
      
      #canvas {
          border: 2px solid #e0e0e0;
          border-radius: 8px;
          max-width: 100%;
          box-shadow: 0 5px 20px rgba(0,0,0,0.1);
      }
      
      .download-btn {
          margin-top: 15px;
          background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      }
      
      .style-section {
          background: #f8f9fa;
          padding: 15px;
          border-radius: 8px;
          margin-bottom: 15px;
      }
      
      .style-section h3 {
          font-size: 14px;
          color: #667eea;
          margin-bottom: 12px;
      }
      
      .quick-colors {
          display: flex;
          gap: 8px;
          margin-top: 8px;
      }
      
      .quick-color {
          width: 30px;
          height: 30px;
          border-radius: 4px;
          cursor: pointer;
          border: 2px solid transparent;
          transition: all 0.2s;
      }
      
      .quick-color:hover {
          border-color: #667eea;
          transform: scale(1.1);
      }

      /* å¤´å›¾å†å²ç¼©ç•¥å›¾ */
      .header-history {
          display: flex;
          gap: 8px;
          margin-top: 10px;
          align-items: center;
      }

      .header-thumb {
          width: 100px;
          height: 70px;
          object-fit: cover;
          border-radius: 8px;
          cursor: pointer;
          border: 2px solid transparent;
          box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      }

      .header-thumb.selected {
          border-color: #667eea;
      }
  </style>
</head>
<body>
  <div class="container">
      <!-- å·¦ä¾§è¾“å…¥é¢æ¿ -->
      <div class="panel">
          <h2>ğŸ“Š ç­–ç•¥å‚æ•°è¾“å…¥</h2>
          
          <div class="form-group">
              <label>ç­–ç•¥ç¼–å·</label>
              <input type="text" id="strategy_id" value="209898" placeholder="ä¾‹å¦‚: 209898">
          </div>
          
          <div class="form-group">
              <label>äº¤æ˜“æ ‡çš„</label>
              <div style="display: flex; gap: 8px;">
                  <select id="symbol_name" style="flex: 1;">
                      <option value="BTC">BTC</option>
                      <option value="ETH">ETH</option>
                  </select>
              </div>
          </div>
          
          <div class="form-group">
              <label>æ“ä½œæ–¹å‘</label>
              <select id="direction">
                  <option value="long">LONG (å¤š)</option>
                  <option value="short">SHORT (ç©º)</option>
              </select>
          </div>
          
          <div class="form-group">
              <label>åŸºç¡€è¿›åœºä»·</label>
              <input type="number" id="entry_price" value="110947" placeholder="ä¾‹å¦‚: 110947">
          </div>
          
          <div class="form-group">
              <label>ç”Ÿæˆå›¾ç‰‡è¯­è¨€</label>
              <select id="language">
                  <option value="en">è‹±è¯­</option>
                  <option value="ru">ä¿„è¯­</option>
                  <option value="vi">è¶Šå—è¯­</option>
                  <option value="ar">é˜¿æ‹‰ä¼¯è¯­</option>
              </select>
          </div>
          
          <div class="style-section">
              <h3>ğŸ¨ å›¾ç‰‡æ ·å¼è®¾ç½®</h3>
              
              <div class="row">
                  <div class="form-group">
                      <label>å­—ä½“å¤§å°</label>
                      <input type="number" id="fontSize" value="25" min="12" max="36">
                  </div>
                  <div class="form-group">
                      <label>å›¾ç‰‡åˆ†è¾¨ç‡å€æ•°</label>
                      <input type="number" id="exportScale" value="2" min="1" max="5" step="0.5">
                  </div>
              </div>
              
              <div class="form-group">
                  <label>æ–‡å­—é¢œè‰²</label>
                  <div class="color-input-group">
                      <input type="color" id="textColor" value="#ffffff">
                      <input type="text" id="textColorHex" value="#ffffff" placeholder="#ffffff">
                      <button class="color-btn" onclick="applyColor('text')">ç¡®å®š</button>
                  </div>
                  <div class="quick-colors">
                      <div class="quick-color" style="background: #ffffff" onclick="setColor('text', '#ffffff')"></div>
                      <div class="quick-color" style="background: #000000" onclick="setColor('text', '#000000')"></div>
                      <div class="quick-color" style="background: #667eea" onclick="setColor('text', '#667eea')"></div>
                      <div class="quick-color" style="background: #38ef7d" onclick="setColor('text', '#38ef7d')"></div>
                      <div class="quick-color" style="background: #ffd700" onclick="setColor('text', '#ffd700')"></div>
                  </div>
              </div>
              
              <div class="form-group">
                  <label>æ–‡å­—èƒŒæ™¯é¢œè‰²</label>
                  <div class="color-input-group">
                      <input type="color" id="textBgColor" value="#1a1a2e">
                      <input type="text" id="textBgColorHex" value="#1a1a2e" placeholder="#1a1a2e">
                      <button class="color-btn" onclick="applyColor('textBg')">ç¡®å®š</button>
                  </div>
                  <div class="quick-colors">
                      <div class="quick-color" style="background: #1a1a2e" onclick="setColor('textBg', '#1a1a2e')"></div>
                      <div class="quick-color" style="background: #2d3436" onclick="setColor('textBg', '#2d3436')"></div>
                      <div class="quick-color" style="background: #0f3460" onclick="setColor('textBg', '#0f3460')"></div>
                      <div class="quick-color" style="background: rgba(0,0,0,0.7)" onclick="setColor('textBg', 'rgba(0,0,0,0.7)')"></div>
                  </div>
              </div>
              
              <div class="row">
                  <div class="form-group">
                      <label>èƒŒæ™¯åœ†è§’</label>
                      <input type="number" id="bgRadius" value="15" min="0" max="50">
                  </div>
                  <div class="form-group">
                      <label>èƒŒæ™¯é€æ˜åº¦</label>
                      <input type="number" id="bgOpacity" value="1" min="0" max="1" step="0.1">
                  </div>
              </div>
          </div>
          
          <div class="form-group">
              <label>ä¸Šä¼ å¤´å›¾</label>
              <input type="file" id="headerImage" accept="image/*">
              <div style="font-size:12px;color:#666;margin-top:8px;">æœ€è¿‘å¤´å›¾ï¼ˆæœ€å¤š 4 æ¡ï¼Œç‚¹å‡»å¯æ¢å¤ï¼‰</div>
              <div id="headerHistory" class="header-history" aria-live="polite"></div>
          </div>
          
          <button onclick="generateImage()">ğŸ¨ ç”Ÿæˆç­–ç•¥å›¾ç‰‡</button>
      </div>
      
      <!-- å³ä¾§é¢„è§ˆé¢æ¿ -->
      <div class="panel preview-section">
          <h2>ğŸ–¼ï¸ å›¾ç‰‡é¢„è§ˆ</h2>
          <canvas id="canvas" width="800" height="1000"></canvas>
          <button class="download-btn" onclick="downloadImage()">â¬‡ï¸ ä¸‹è½½å›¾ç‰‡</button>
      </div>
  </div>

  <script>
      // è¯­è¨€æ¨¡æ¿
      const templates = {
          en: {
              title: "âœ… Strategy ID {strategy_id}",
              lines: [
                  "{symbol_name} (Total Position {total_position_pct}%)",
                  "Entry Range: {price_low} â€“ {price_high}",
                  "Direction: {direction}",
                  "Max Position Size: {total_position_pct}%",
                  "Leverage: {leverage}x",
                  "Partial Take-Profit Prices: {tp1} / {tp2} / {tp3}",
                  "Stop Loss: {sl}"
              ],
              align: "left",
              font: "Arial, sans-serif"
              ,directionLabels: { long: 'Long', short: 'Short' }
          },
          ru: {
              title: "âœ… Ğ¡Ñ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ â„–{strategy_id}",
              lines: [
                  "{symbol_name} (ĞĞ±Ñ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ {total_position_pct}%)",
                  "Ğ”Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½ Ğ²Ñ…Ğ¾Ğ´Ğ°: {price_low} â€“ {price_high}",
                  "ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ: {direction}",
                  "ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸: {total_position_pct}%",
                  "ĞŸĞ»ĞµÑ‡Ğ¾: {leverage}x",
                  "Ğ¦ĞµĞ½Ñ‹ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾Ğ¹ Ñ„Ğ¸ĞºÑĞ°Ñ†Ğ¸Ğ¸ Ğ¿Ñ€Ğ¸Ğ±Ñ‹Ğ»Ğ¸: {tp1} / {tp2} / {tp3}",
                  "Ğ¡Ñ‚Ğ¾Ğ¿-Ğ»Ğ¾ÑÑ: {sl}"
              ],
              align: "left",
              font: "Arial, sans-serif"
              ,directionLabels: { long: 'Ğ”Ğ»Ğ¸Ğ½Ğ½Ğ°Ñ', short: 'ĞšĞ¾Ñ€Ğ¾Ñ‚ĞºĞ°Ñ' }
          },
          vi: {
              title: "âœ… Chiáº¿n lÆ°á»£c sá»‘ {strategy_id}",
              lines: [
                  "{symbol_name} (Tá»•ng vá»‹ tháº¿ {total_position_pct}%)",
                  "VÃ¹ng vÃ o lá»‡nh: {price_low} â€“ {price_high}",
                  "HÆ°á»›ng giao dá»‹ch: {direction}",
                  "Giá»›i háº¡n vá»‹ tháº¿: {total_position_pct}%",
                  "ÄÃ²n báº©y: {leverage}x",
                  "GiÃ¡ chá»‘t lá»i tá»«ng pháº§n: {tp1} / {tp2} / {tp3}",
                  "Cáº¯t lá»—: {sl}"
              ],
              align: "left",
              font: "Arial, sans-serif"
              ,directionLabels: { long: 'Mua (Long)', short: 'BÃ¡n (Short)' }
          },
          ar: {
              title: "âœ… Ø±Ù‚Ù… Ø§Ù„Ø¥Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© {strategy_id}",
              lines: [
                  "{symbol_name} (Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© {total_position_pct}%)",
                  "Ù†Ø·Ø§Ù‚ Ø§Ù„Ø¯Ø®ÙˆÙ„: {price_low} â€“ {price_high}",
                  "Ø§Ù„Ø§ØªØ¬Ø§Ù‡: {direction}",
                  "Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø©: {total_position_pct}%",
                  "Ø§Ù„Ø±Ø§ÙØ¹Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ©: {leverage}x",
                  "Ø£Ø³Ø¹Ø§Ø± Ø¬Ù†ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ Ø§Ù„Ø¬Ø²Ø¦ÙŠØ©: {tp1} / {tp2} / {tp3}",
                  "Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©: {sl}"
              ],
              align: "right",
              font: "Arial, sans-serif"
              ,directionLabels: { long: 'Ø´Ø±Ø§Ø¡', short: 'Ø¨ÙŠØ¹' }
          }
      };

      let headerImageData = null;

      // è®¡ç®—ç­–ç•¥å‚æ•°
      function calculateStrategy(symbolName, entryPrice, direction) {
          const symbol = symbolName.toUpperCase();
          const offset = symbol.includes('BTC') ? 100 : 10;
          
          // åˆ¤æ–­æ˜¯å¤šå•è¿˜æ˜¯ç©ºå•
          const isLong = direction === 'long';
          
          return {
              price_low: Math.round(entryPrice - offset),    // BTC: entry_price-100, ETH: entry_price-10
              price_high: Math.round(entryPrice + offset),   // BTC: entry_price+100, ETH: entry_price+10
              leverage: 100,                                 // å›ºå®šå€¼
              total_position_pct: 5,                         // å›ºå®šå€¼
              // å¤šå•ï¼šå‘ä¸Šæ­¢ç›ˆï¼Œå‘ä¸‹æ­¢æŸ
              // ç©ºå•ï¼šå‘ä¸‹æ­¢ç›ˆï¼Œå‘ä¸Šæ­¢æŸ
              tp1: isLong ? 
                  Math.round(entryPrice * (1 + 0.012)) :    // å¤šå•ï¼šentry_price Ã— (1+0.012)
                  Math.round(entryPrice * (1 - 0.012)),     // ç©ºå•ï¼šentry_price Ã— (1-0.012)
              tp2: isLong ? 
                  Math.round(entryPrice * (1 + 0.018)) :    // å¤šå•ï¼šentry_price Ã— (1+0.018)
                  Math.round(entryPrice * (1 - 0.018)),     // ç©ºå•ï¼šentry_price Ã— (1-0.018)
              tp3: isLong ? 
                  Math.round(entryPrice * (1 + 0.03)) :     // å¤šå•ï¼šentry_price Ã— (1+0.03)
                  Math.round(entryPrice * (1 - 0.03)),      // ç©ºå•ï¼šentry_price Ã— (1-0.03)
              sl: isLong ? 
                  Math.round(entryPrice * (1 - 0.01)) :     // å¤šå•ï¼šentry_price Ã— (1-0.01)
                  Math.round(entryPrice * (1 + 0.01))       // ç©ºå•ï¼šentry_price Ã— (1+0.01)
          };
      }

      // é¢œè‰²é€‰æ‹©å™¨åŒæ­¥ä¸åº”ç”¨
      document.getElementById('textColor').addEventListener('input', (e) => {
          document.getElementById('textColorHex').value = e.target.value;
          generateImage(); // é¢œè‰²é€‰æ‹©å™¨å˜åŒ–æ—¶å®æ—¶é¢„è§ˆ
      });
      
      document.getElementById('textBgColor').addEventListener('input', (e) => {
          document.getElementById('textBgColorHex').value = e.target.value;
          generateImage(); // é¢œè‰²é€‰æ‹©å™¨å˜åŒ–æ—¶å®æ—¶é¢„è§ˆ
      });
      
      // ç¡®è®¤æŒ‰é’®åº”ç”¨é¢œè‰²
      function applyColor(type) {
          const hexInput = document.getElementById(type === 'text' ? 'textColorHex' : 'textBgColorHex');
          const colorPicker = document.getElementById(type === 'text' ? 'textColor' : 'textBgColor');
          
          // éªŒè¯é¢œè‰²æ ¼å¼
          const colorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
          let color = hexInput.value.trim();
          
          // å¦‚æœæ²¡æœ‰#å·ï¼Œæ·»åŠ #å·
          if (!color.startsWith('#')) {
              color = '#' + color;
          }
          
          // éªŒè¯é¢œè‰²å€¼
          if (colorRegex.test(color)) {
              colorPicker.value = color;
              hexInput.value = color;
              generateImage(); // åº”ç”¨æ–°é¢œè‰²å¹¶é‡æ–°ç”Ÿæˆå›¾ç‰‡
              // åªæœ‰åœ¨ç”¨æˆ·ç‚¹å‡»ã€ç¡®å®šã€‘æ—¶ï¼Œæ‰æŠŠå½“å‰é¢œè‰²ä¿å­˜åˆ°å¯¹åº”çš„å†å²è®°å½•
              try {
                  if (type === 'text') {
                      saveTextColor();
                  } else {
                      saveBgColor();
                  }
              } catch (e) {
                  // å¿½ç•¥ä¿å­˜é”™è¯¯ï¼Œä»ç„¶ä¿æŒé¢„è§ˆæ›´æ–°
                  console.warn('ä¿å­˜é¢œè‰²å¤±è´¥', e);
              }
          } else {
              alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é¢œè‰²å€¼ï¼Œä¾‹å¦‚: #FF0000');
              // æ¢å¤ä¸ºé¢œè‰²é€‰æ‹©å™¨çš„å½“å‰å€¼
              hexInput.value = colorPicker.value;
          }
      }

      // å½“è¯­è¨€æ”¹å˜æ—¶ï¼Œæ›´æ–° direction é€‰é¡¹æ–‡æœ¬ä¸ºå¯¹åº”è¯­è¨€
      function updateDirectionLabels() {
          const lang = document.getElementById('language').value;
          const tpl = templates[lang] || templates['en'];
          const labels = tpl.directionLabels || { long: 'Long', short: 'Short' };
          const sel = document.getElementById('direction');
          // ä¿ç•™å½“å‰é€‰ä¸­å€¼
          const current = sel.value;
          sel.innerHTML = '';
          const optLong = document.createElement('option');
          optLong.value = 'long';
          optLong.textContent = labels.long;
          const optShort = document.createElement('option');
          optShort.value = 'short';
          optShort.textContent = labels.short;
          sel.appendChild(optLong);
          sel.appendChild(optShort);
          // æ¢å¤ä¹‹å‰çš„é€‰æ‹©ï¼ˆè‹¥ä»å¯ç”¨ï¼‰
          if (current === 'long' || current === 'short') sel.value = current;
      }

      document.getElementById('language').addEventListener('change', () => {
          updateDirectionLabels();
      });

      // å¿«é€Ÿé¢œè‰²é€‰æ‹©
      function setColor(type, color) {
          if (type === 'text') {
              document.getElementById('textColor').value = color;
              document.getElementById('textColorHex').value = color;
          } else {
              document.getElementById('textBgColor').value = color;
              document.getElementById('textBgColorHex').value = color;
          }
          // ä»…åˆ·æ–°é¢„è§ˆï¼Œä¸ä¿å­˜å†å²ï¼ˆç”¨æˆ·éœ€ç‚¹å‡»â€œç¡®å®šâ€æ¥ä¿å­˜ï¼‰
          generateImage();
      }

      // ä¸Šä¼ å¤´å›¾
      // ä¿å­˜é…ç½®åˆ°æœ¬åœ°å­˜å‚¨
      function saveConfig() {
          const config = {
              strategy_id: document.getElementById('strategy_id').value,
              symbol_name: document.getElementById('symbol_name').value,
              direction: document.getElementById('direction').value,
              entry_price: document.getElementById('entry_price').value,
              language: document.getElementById('language').value,
              fontSize: document.getElementById('fontSize').value,
              exportScale: document.getElementById('exportScale').value
          };
          localStorage.setItem('lastConfig', JSON.stringify(config));
      }

      // åŠ è½½ä¸Šæ¬¡çš„é…ç½®
      function loadLastConfig() {
          const lastConfig = localStorage.getItem('lastConfig');
          if (lastConfig) {
              const config = JSON.parse(lastConfig);
              Object.entries(config).forEach(([key, value]) => {
                  const element = document.getElementById(key);
                  if (element) {
                      element.value = value;
                  }
              });
          }
      }

      // é¢œè‰²è®°å½•ç®¡ç†
      const MAX_COLOR_HISTORY = 4;
      
      function loadSavedColors() {
          // åŠ è½½æ–‡å­—é¢œè‰²å’ŒèƒŒæ™¯é¢œè‰²çš„ç‹¬ç«‹å†å²è®°å½•
          const textHistory = JSON.parse(localStorage.getItem('textColorHistory') || '[]');
          const bgHistory = JSON.parse(localStorage.getItem('bgColorHistory') || '[]');

          if (textHistory.length > 0) {
              document.getElementById('textColor').value = textHistory[0];
              document.getElementById('textColorHex').value = textHistory[0];
          }
          if (bgHistory.length > 0) {
              document.getElementById('textBgColor').value = bgHistory[0];
              document.getElementById('textBgColorHex').value = bgHistory[0];
          }

          // åˆ›å»ºä¸¤ç»„å†å²æŒ‰é’®
          createColorHistoryButtons('text', textHistory);
          createColorHistoryButtons('bg', bgHistory);
      }

      // åˆ›å»ºé¢œè‰²å†å²æŒ‰é’®ï¼ˆtype = 'text' æˆ– 'bg'ï¼‰
      function createColorHistoryButtons(type, history) {
          const selector = type === 'text' ? '.form-group:has(#textColor) .quick-colors' : '.form-group:has(#textBgColor) .quick-colors';
          const container = document.querySelector(selector);
          if (!container) return;

          container.innerHTML = '';

          history.slice(0, MAX_COLOR_HISTORY).forEach((color, index) => {
              const btn = document.createElement('div');
              btn.className = 'quick-color';
              btn.style.background = color;
              btn.title = `å†å²é¢œè‰² ${index + 1}`;
              btn.dataset.color = color;
              btn.onclick = () => {
                  if (type === 'text') {
                      document.getElementById('textColor').value = color;
                      document.getElementById('textColorHex').value = color;
                  } else {
                      document.getElementById('textBgColor').value = color;
                      document.getElementById('textBgColorHex').value = color;
                  }
                  generateImage();
              };
              container.appendChild(btn);
          });
      }

      // ä¿å­˜æ–‡å­—é¢œè‰²å†å²
      function saveTextColor() {
          const color = document.getElementById('textColor').value.toLowerCase();
          let history = JSON.parse(localStorage.getItem('textColorHistory') || '[]');
          history = history.filter(c => c.toLowerCase() !== color);
          history.unshift(color);
          history = history.slice(0, MAX_COLOR_HISTORY);
          localStorage.setItem('textColorHistory', JSON.stringify(history));
          createColorHistoryButtons('text', history);
      }

      // ä¿å­˜èƒŒæ™¯é¢œè‰²å†å²
      function saveBgColor() {
          const color = document.getElementById('textBgColor').value.toLowerCase();
          let history = JSON.parse(localStorage.getItem('bgColorHistory') || '[]');
          history = history.filter(c => c.toLowerCase() !== color);
          history.unshift(color);
          history = history.slice(0, MAX_COLOR_HISTORY);
          localStorage.setItem('bgColorHistory', JSON.stringify(history));
          createColorHistoryButtons('bg', history);
      }

      // ä¿å­˜æœ€åä½¿ç”¨çš„å¤´å›¾
      function saveLastHeaderImage(file) {
          return new Promise((resolve, reject) => {
              try {
                  const reader = new FileReader();
                  reader.onload = (event) => {
                      // åˆ›å»ºä¸€ä¸ªä¸´æ—¶å›¾ç‰‡æ¥è·å–å›¾ç‰‡å°ºå¯¸
                      const img = new Image();
                      img.onload = () => {
                          // åˆ›å»ºcanvasæ¥å‹ç¼©å›¾ç‰‡
                          const canvas = document.createElement('canvas');
                          const ctx = canvas.getContext('2d');
                          
                          // è®¡ç®—å‹ç¼©åçš„å°ºå¯¸ï¼Œä¿æŒå®½é«˜æ¯”
                          let width = img.width;
                          let height = img.height;
                          const MAX_WIDTH = 1200; // æœ€å¤§å®½åº¦
                          
                          if (width > MAX_WIDTH) {
                              height = Math.round(height * (MAX_WIDTH / width));
                              width = MAX_WIDTH;
                          }
                          
                          canvas.width = width;
                          canvas.height = height;
                          
                          // ç»˜åˆ¶å¹¶å‹ç¼©å›¾ç‰‡
                          ctx.drawImage(img, 0, 0, width, height);
                          
                          // è½¬æ¢ä¸ºè¾ƒå°çš„JPEGæ ¼å¼
                          const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                          
                          // ä¿å­˜å‹ç¼©åçš„å›¾ç‰‡æ•°æ®
                          // æŒä¹…åŒ–ä¸ºæœ€è¿‘ä¸€æ¬¡ï¼Œå¹¶åŠ å…¥å†å²
                          localStorage.setItem('lastHeaderImage', compressedDataUrl);
                          localStorage.setItem('headerImageTimestamp', Date.now());
                          // å°†å›¾ç‰‡åŠ å…¥å†å²ï¼ˆrecent 4ï¼‰
                          try {
                              saveHeaderHistory(compressedDataUrl);
                          } catch (e) {
                              console.warn('ä¿å­˜å¤´å›¾å†å²å¤±è´¥', e);
                          }
                          resolve(compressedDataUrl);
                      };
                      img.onerror = reject;
                      img.src = event.target.result;
                  };
                  reader.onerror = reject;
                  reader.readAsDataURL(file);
              } catch (error) {
                  reject(error);
              }
          });
      }

      // ä¿å­˜å¤´å›¾åˆ°å†å²ï¼ˆæœ€å¤šä¿ç•™ 4 æ¡ï¼‰ï¼ŒdataUrl å¿…é¡»æ˜¯å‹ç¼©åçš„ DataURL
      function saveHeaderHistory(dataUrl) {
          if (!dataUrl) return;
          let history = JSON.parse(localStorage.getItem('headerImageHistory') || '[]');
          // å»é‡ï¼šè‹¥å·²å­˜åœ¨åˆ™ç§»é™¤æ—§é¡¹
          history = history.filter(item => item !== dataUrl);
          history.unshift(dataUrl);
          history = history.slice(0, 4);
          localStorage.setItem('headerImageHistory', JSON.stringify(history));
          renderHeaderHistory();
      }

      // æ¸²æŸ“å¤´å›¾å†å²ç¼©ç•¥å›¾
      function renderHeaderHistory() {
          const container = document.getElementById('headerHistory');
          if (!container) return;
          const history = JSON.parse(localStorage.getItem('headerImageHistory') || '[]');
          container.innerHTML = '';
          history.forEach((dataUrl, idx) => {
              const img = document.createElement('img');
              img.src = dataUrl;
              img.className = 'header-thumb';
              img.title = `æœ€è¿‘å¤´å›¾ ${idx + 1}`;
              img.addEventListener('click', () => {
                  // ç‚¹å‡»ç¼©ç•¥å›¾æ¢å¤ä¸ºå½“å‰å¤´å›¾å¹¶æŒä¹…åŒ–ä¸º lastHeaderImage
                  const restoreImg = new Image();
                  restoreImg.onload = () => {
                      headerImageData = restoreImg;
                      // å°†æ‰€é€‰ç¼©ç•¥å›¾è®¾ä¸º lastHeaderImage
                      localStorage.setItem('lastHeaderImage', dataUrl);
                      localStorage.setItem('headerImageTimestamp', Date.now());
                      // æ›´æ–°ç¼©ç•¥é€‰ä¸­æ ·å¼
                      Array.from(container.children).forEach(c => c.classList.remove('selected'));
                      img.classList.add('selected');
                      generateImage();
                  };
                  restoreImg.src = dataUrl;
              });
              container.appendChild(img);
          });
      }

      function loadLastHeaderImage() {
          const lastImageData = localStorage.getItem('lastHeaderImage');
          const timestamp = localStorage.getItem('headerImageTimestamp');
          
          if (lastImageData && timestamp) {
              // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦æ˜¯åœ¨æœ€è¿‘24å°æ—¶å†…ä¿å­˜çš„
              const isRecent = (Date.now() - parseInt(timestamp)) < (24 * 60 * 60 * 1000);
              
              if (isRecent) {
                  const img = new Image();
                  img.onload = () => {
                      headerImageData = img;
                      generateImage();
                  };
                  img.src = lastImageData;
              } else {
                  // å¦‚æœå›¾ç‰‡å¤ªæ—§ï¼Œæ¸…é™¤å­˜å‚¨
                  localStorage.removeItem('lastHeaderImage');
                  localStorage.removeItem('headerImageTimestamp');
              }
          }
      }

      // åŠ è½½å¤´å›¾å†å²å¹¶æ¸²æŸ“ï¼ˆä¾›åˆå§‹åŒ–ä½¿ç”¨ï¼‰
      function loadHeaderHistory() {
          renderHeaderHistory();
          // å¦‚æœ lastHeaderImage ä¸å­˜åœ¨ä½†å†å²å­˜åœ¨ï¼Œåˆ™ä½¿ç”¨å†å²ç¬¬ä¸€é¡¹ä½œä¸º last
          const last = localStorage.getItem('lastHeaderImage');
          const history = JSON.parse(localStorage.getItem('headerImageHistory') || '[]');
          if (!last && history.length > 0) {
              localStorage.setItem('lastHeaderImage', history[0]);
              localStorage.setItem('headerImageTimestamp', Date.now());
          }
      }

      // é¢œè‰²å˜åŒ–æ—¶ä»…æ›´æ–°é¢„è§ˆï¼ˆä¸è¦åœ¨æ»‘åŠ¨/è¾“å…¥æ—¶è®°å½•å†å²ï¼‰
      document.getElementById('textColor').addEventListener('input', () => {
          generateImage();
      });
      document.getElementById('textBgColor').addEventListener('input', () => {
          generateImage();
      });

      // é…ç½®å˜åŒ–æ—¶ä¿å­˜
      ['strategy_id', 'symbol_name', 'direction', 'entry_price', 'language', 'fontSize', 'exportScale'].forEach(id => {
          document.getElementById(id).addEventListener('change', saveConfig);
      });

      document.getElementById('headerImage').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (file) {
              try {
                  // ä¿å­˜å¹¶è·å–å‹ç¼©åçš„å›¾ç‰‡æ•°æ®
                  const compressedDataUrl = await saveLastHeaderImage(file);
                  
                  // åŠ è½½å‹ç¼©åçš„å›¾ç‰‡åˆ°é¢„è§ˆ
                  const img = new Image();
                  img.onload = () => {
                      headerImageData = img;
                      generateImage();
                  };
                  img.src = compressedDataUrl;
              } catch (error) {
                  console.error('Error processing image:', error);
                  alert('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·å°è¯•ä½¿ç”¨è¾ƒå°çš„å›¾ç‰‡');
              }
          }
      });

      // ç”Ÿæˆå›¾ç‰‡ï¼ˆå¯é€‰ï¼šä¼ å…¥ targetCanvas ä¸ scale ä»¥ç”Ÿæˆæ›´é«˜æ¸…çš„å¯¼å‡ºç”»å¸ƒï¼‰
      function generateImage(targetCanvas = null, scale = 1) {
          const canvas = targetCanvas || document.getElementById('canvas');

          // è·å–è¾“å…¥å€¼
          const strategyId = document.getElementById('strategy_id').value;
          const symbolName = document.getElementById('symbol_name').value;
          const direction = document.getElementById('direction').value;
          const entryPrice = parseFloat(document.getElementById('entry_price').value);
          const language = document.getElementById('language').value;
          
          // æ ·å¼å‚æ•°
          const fontSize = parseInt(document.getElementById('fontSize').value);
          const textColor = document.getElementById('textColor').value;
          const textBgColor = document.getElementById('textBgColor').value;
          const bgRadius = parseInt(document.getElementById('bgRadius').value);
          const bgOpacity = parseFloat(document.getElementById('bgOpacity').value);

          // è®¡ç®—ç­–ç•¥å‚æ•°
          const calculated = calculateStrategy(symbolName, entryPrice, direction);
          
          // å‡†å¤‡æ•°æ®
          const data = {
              strategy_id: strategyId,
              symbol_name: symbolName,
              direction: direction,
              entry_price: entryPrice,
              ...calculated
          };
          
          // è·å–æ¨¡æ¿
          const template = templates[language] || templates['en'];

          // å°† direction å†…éƒ¨å€¼æ˜ å°„ä¸ºæ¨¡æ¿è¯­è¨€çš„æ˜¾ç¤ºæ–‡æœ¬ï¼ˆlong/short -> æœ¬åœ°åŒ–å­—ç¬¦ä¸²ï¼‰
          const dirValue = document.getElementById('direction').value; // 'long' or 'short'
          const localizedDirection = (template.directionLabels && template.directionLabels[dirValue]) ? template.directionLabels[dirValue] : (dirValue === 'long' ? 'Long' : 'Short');
          
          // æŠŠæœ¬åœ°åŒ– direction æ”¾å…¥ data ä¸­ï¼Œè¿™æ ·æ¨¡æ¿æ›¿æ¢ {direction} æ—¶ä¼šä½¿ç”¨æ­£ç¡®è¯­è¨€
          data.direction = localizedDirection;

          // å…ˆè®¡ç®—éœ€è¦çš„é«˜åº¦ï¼ˆä¸æ”¹å˜ç°æœ‰ canvas å†…å®¹ï¼‰
          const scaleFactor = scale || 1;
          const paddingScaled = Math.round(30 * scaleFactor);
          const fontSizeScaled = Math.round(fontSize * scaleFactor);
          const titleFontScaled = Math.round((fontSize + 4) * scaleFactor);
          const lineHeight = fontSizeScaled * 1.8;
          const titleText = template && template.title ? template.title.replace(/{(\w+)}/g, (m,k) => data[k] || m) : '';
          const contentLines = template && template.lines ? template.lines.map(line => line.replace(/{(\w+)}/g, (m,k) => data[k] || m)) : [];

          const bgHeight = Math.round(lineHeight * (contentLines.length + 2) + paddingScaled * 2);

          // å¤´å›¾é«˜åº¦é¢„æµ‹ï¼ˆè‹¥æœ‰å¤´å›¾ï¼‰
          const canvasWidth = canvas.width;
          let headerDrawHeight = 0;
          let topSpacing = 0; // è‹¥æ— å¤´å›¾ï¼Œç”¨ä½œé¡¶éƒ¨ç©ºç™½
          if (headerImageData) {
              const imgAspect = headerImageData.width / headerImageData.height;
              headerDrawHeight = Math.round(canvasWidth / imgAspect);
              topSpacing = 0;
          } else {
              headerDrawHeight = 0;
              topSpacing = Math.round(50 * scaleFactor); // ä¿æŒä¸ä¹‹å‰ä¸€è‡´çš„é»˜è®¤é¡¶éƒ¨ç©ºç™½ï¼Œå¹¶éš scale ç¼©æ”¾
          }

          const bottomPadding = 40;
          const totalHeight = topSpacing + headerDrawHeight + bgHeight + bottomPadding;

          // è®¾ç½® canvas é«˜åº¦ï¼ˆä¼šé‡ç½®ç”»å¸ƒçŠ¶æ€ï¼‰ï¼Œç„¶åé‡æ–°è·å– ctx
          canvas.height = Math.max(totalHeight, 200);
          const ctx = canvas.getContext('2d', { alpha: false });
          
          // é’ˆå¯¹é«˜åˆ†è¾¨ç‡å¯¼å‡ºä¼˜åŒ–æ¸²æŸ“è®¾ç½®
          if (scale > 1) {
              // å¯¹äºé«˜åˆ†è¾¨ç‡å¯¼å‡ºï¼Œç¦ç”¨å¹³æ»‘ä»¥å®ç°ç‚¹å¯¹ç‚¹æ¸²æŸ“
              ctx.imageSmoothingEnabled = false;
              // è®¾ç½®æ–‡å­—æ¸²æŸ“ä¼˜åŒ–
              ctx.textRendering = "geometricPrecision";
              ctx.fontKerning = "normal";
          } else {
              // é¢„è§ˆæ—¶ä¿æŒå¹³æ»‘
              ctx.imageSmoothingEnabled = true;
          }

          // æ¸…ç©ºç”»å¸ƒ â€” ä½¿ç”¨æ–‡å­—èƒŒæ™¯è‰²ä½œä¸ºç”»å¸ƒåº•è‰²ä»¥å‡å°‘åŠé€æ˜å±‚å æ—¶çš„è‰²å·®æ¥ç¼
          ctx.fillStyle = textBgColor || '#f0f0f0';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // ç»˜åˆ¶å¤´å›¾ï¼ˆè‹¥æœ‰ï¼‰ï¼Œå¹¶ç´§è´´åç»­å†…å®¹ï¼ˆä¸é¢å¤–å¢åŠ é—´éš™ï¼‰
          let currentY = topSpacing;
          if (headerImageData) {
              const headerWidth = canvas.width;
              const drawHeight = headerDrawHeight;
              ctx.drawImage(headerImageData, 0, 0, headerWidth, drawHeight);
              currentY += drawHeight; // ç›´æ¥ç´§è´´
          }

          // ç»˜åˆ¶æ–‡å­—èƒŒæ™¯
          const bgY = Math.round(currentY);
          // ç»˜åˆ¶åœ†è§’çŸ©å½¢èƒŒæ™¯
          ctx.globalAlpha = bgOpacity;
          ctx.fillStyle = textBgColor;
          const bgRadiusScaled = Math.round(bgRadius * scaleFactor);
          roundRect(ctx, paddingScaled, bgY, canvas.width - paddingScaled * 2, bgHeight, bgRadiusScaled);
          ctx.fill();
          ctx.globalAlpha = 1;

          // è®¾ç½®æ–‡å­—æ ·å¼ï¼ˆä½¿ç”¨ç¼©æ”¾åçš„å­—ä½“å°ºå¯¸ï¼‰
          ctx.fillStyle = textColor;
          ctx.font = `bold ${titleFontScaled}px ${template.font}`;
          ctx.textAlign = template.align;
          
          const textX = template.align === 'right' ? canvas.width - paddingScaled - Math.round(20 * scaleFactor) : paddingScaled + Math.round(20 * scaleFactor);
          let textY = bgY + paddingScaled + fontSizeScaled + Math.round(10 * scaleFactor);

          // ç»˜åˆ¶æ ‡é¢˜
          ctx.fillText(titleText.replace(/{(\w+)}/g, (m,k) => data[k] || m), textX, textY);

          // ç»˜åˆ¶å†…å®¹
          ctx.font = `${fontSizeScaled}px ${template.font}`;
          textY += lineHeight * 1.5;
          contentLines.forEach((line, index) => {
              // åˆ¤æ–­æ˜¯å¦æ˜¯ Direction è¡Œ
              if (line.includes(localizedDirection)) {
                  // ä¿å­˜å½“å‰çŠ¶æ€
                  ctx.save();
                  
                  // è®¾ç½®æè¾¹æ ·å¼
                  ctx.strokeStyle = '#FFFFFF';  // ç™½è‰²æè¾¹
                  ctx.lineWidth = Math.max(1, Math.round(3 * scaleFactor));  // æè¾¹å®½åº¦ï¼Œéšåˆ†è¾¨ç‡ç¼©æ”¾
                  ctx.lineJoin = 'round';      // åœ†è§’è¿æ¥
                  ctx.miterLimit = 2;          // é™åˆ¶å°–è§’
                  
                  // æ ¹æ®æ–¹å‘è®¾ç½®å¡«å……é¢œè‰²
                  if (direction === 'long') {
                      ctx.fillStyle = '#00DA90'; // å¤šå¤´ç»¿è‰²
                  } else if (direction === 'short') {
                      ctx.fillStyle = '#F04343'; // ç©ºå¤´çº¢è‰²
                  }
                  
                  // å…ˆç»˜åˆ¶æè¾¹ï¼Œå†ç»˜åˆ¶æ–‡å­—ï¼ˆè¿™æ ·æ–‡å­—ä¼šåœ¨æè¾¹ä¸Šå±‚ï¼‰
                  ctx.strokeText(line, textX, textY);
                  ctx.fillText(line, textX, textY);
                  
                  // æ¢å¤ä¹‹å‰çš„çŠ¶æ€
                  ctx.restore();
              } else {
                  ctx.fillText(line, textX, textY);
              }
              textY += lineHeight;
          });
      }

      // ç»˜åˆ¶åœ†è§’çŸ©å½¢
      function roundRect(ctx, x, y, width, height, radius) {
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
      }

      // ä¸‹è½½å›¾ç‰‡ â€” ä»¥æ›´é«˜åˆ†è¾¨ç‡é‡æ–°æ¸²æŸ“åŸå§‹é•¿å›¾ï¼ˆä¿æŒé•¿å›¾æ¯”ä¾‹ä¸å˜ï¼‰
      function downloadImage() {
          const preview = document.getElementById('canvas');

          // å…ˆé‡æ–°ç”Ÿæˆä¸€æ¬¡é¢„è§ˆï¼Œä¿è¯ç­–ç•¥ä¿¡æ¯ã€å¤´å›¾å’Œé¢œè‰²ç­‰éƒ½æ˜¯æœ€æ–°çš„
          generateImage();

          const baseW = preview.width;
          const baseH = preview.height;

          // ä»è¾“å…¥æ¡†è·å–å¯¼å‡ºåˆ†è¾¨ç‡å€æ•°
          const exportScale = parseFloat(document.getElementById('exportScale').value) || 2;

          // åˆ›å»ºä¸€ä¸ªç”¨äºé«˜åˆ†è¾¨ç‡æ¸²æŸ“çš„ä¸´æ—¶ç”»å¸ƒ
          const temp = document.createElement('canvas');
          temp.width = Math.round(baseW * exportScale);
          temp.height = Math.round(baseH * exportScale);

          // ä½¿ç”¨ generateImage åœ¨ä¸´æ—¶ç”»å¸ƒä¸Šä»¥ exportScale é‡ç»˜ï¼ˆå‘é‡æ–¹å¼æ¸²æŸ“ï¼Œæ–‡å­—æ›´æ¸…æ™°ï¼‰
          generateImage(temp, exportScale);

          // å¯¼å‡º PNG
          const link = document.createElement('a');
          const strategyId = document.getElementById('strategy_id').value;
          link.download = `strategy_${strategyId}_x${exportScale}.png`;
          link.href = temp.toDataURL('image/png');
          link.click();
      }

      // åˆå§‹åŒ–ç”Ÿæˆ
      window.onload = () => {
          loadLastConfig();     // åŠ è½½ä¸Šæ¬¡çš„é…ç½®
          loadSavedColors();    // åŠ è½½ä¿å­˜çš„é¢œè‰²
          loadHeaderHistory();  // åŠ è½½å¤´å›¾å†å²å¹¶æ¸²æŸ“
          loadLastHeaderImage(); // åŠ è½½ä¸Šæ¬¡ä½¿ç”¨çš„å¤´å›¾
          updateDirectionLabels();
          generateImage();
      };
  </script>
</body>
</html>