<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ç­–ç•¥å›¾ç‰‡ç”Ÿæˆå™¨ - é¢‘é“ç‰ˆ</title>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        font-weight: bold;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        min-height: 100vh;
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        display: grid;
        grid-template-columns: 450px 1fr;
        gap: 20px;
    }
    
    .panel {
        background: white;
        border-radius: 12px;
        padding: 25px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.1);
    }
    
    h2 {
        color: #333;
        margin-bottom: 20px;
        font-size: 20px;
        border-bottom: 2px solid #667eea;
        padding-bottom: 10px;
    }
    
    .form-group {
        margin-bottom: 15px;
    }
    
    label {
        display: block;
        margin-bottom: 5px;
        color: #555;
        font-weight: 600;
        font-size: 13px;
    }
    
    input, select {
        width: 100%;
        padding: 10px;
        border: 2px solid #e0e0e0;
        border-radius: 6px;
        font-size: 14px;
        transition: border-color 0.3s;
    }
    
    input:focus, select:focus {
        outline: none;
        border-color: #667eea;
    }
    
    .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
    }

    input[type="file"] {
        padding: 8px;
    }
    
    button {
        width: 100%;
        padding: 12px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s;
        margin-top: 10px;
    }
    
    button:hover {
        transform: translateY(-2px);
    }
    
    button:active {
        transform: translateY(0);
    }
    
    .preview-section {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    #canvas {
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        max-width: 100%;
        box-shadow: 0 5px 20px rgba(0,0,0,0.1);
    }
    
    .download-btn {
        margin-top: 15px;
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
    }
    
    .style-section {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 15px;
    }
    
    .style-section h3 {
        font-size: 14px;
        color: #667eea;
        margin-bottom: 12px;
    }

    /* é¢‘é“å¡ç‰‡æ ·å¼ */
    .channel-section {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
    }

    .channel-section h3 {
        font-size: 14px;
        color: white;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .channel-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
    }

    .channel-card {
        background: white;
        border-radius: 8px;
        padding: 12px;
        cursor: pointer;
        transition: all 0.3s;
        border: 2px solid transparent;
        position: relative;
    }

    .channel-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        border-color: #667eea;
    }

    .channel-card.active {
        border-color: #38ef7d;
        background: #f0fff4;
    }

    .channel-name {
        font-weight: bold;
        color: #333;
        font-size: 13px;
        margin-bottom: 6px;
    }

    .channel-info {
        font-size: 11px;
        color: #666;
        display: flex;
        flex-direction: column;
        gap: 3px;
    }

    .channel-preview {
        width: 100%;
        height: 60px;
        border-radius: 4px;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        color: white;
        font-weight: bold;
    }

    .channel-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
    }

    .channel-btn {
        flex: 1 1 calc(50% - 8px);
        padding: 8px;
        font-size: 12px;
        margin: 0;
        border-radius: 4px;
    }

    .btn-add {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .btn-manage {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .btn-export {
        background: linear-gradient(135deg, #42e695 0%, #3bb2b8 100%);
    }

    .btn-import {
        background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
    }

    .btn-generate-all {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        font-size: 16px;
        padding: 15px;
    }

    /* å¼¹çª—æ ·å¼ */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        animation: fadeIn 0.3s;
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    .modal-content {
        background-color: white;
        margin: 5% auto;
        padding: 30px;
        border-radius: 12px;
        width: 90%;
        max-width: 700px;
        max-height: 80vh;
        overflow-y: auto;
        animation: slideIn 0.3s;
    }

    @keyframes slideIn {
        from {
            transform: translateY(-50px);
            opacity: 0;
        }
        to {
            transform: translateY(0);
            opacity: 1;
        }
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #667eea;
    }

    .modal-header h2 {
        margin: 0;
        border: none;
        padding: 0;
    }

    .close {
        font-size: 28px;
        font-weight: bold;
        color: #aaa;
        cursor: pointer;
        line-height: 1;
    }

    .close:hover {
        color: #000;
    }

    .channel-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .channel-item {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border: 2px solid transparent;
        transition: all 0.3s;
    }

    .channel-item:hover {
        border-color: #667eea;
    }

    .channel-item-info {
        flex: 1;
    }

    .channel-item-actions {
        display: flex;
        gap: 8px;
    }

    .icon-btn {
        padding: 8px 12px;
        font-size: 12px;
        border-radius: 4px;
        cursor: pointer;
        border: none;
        color: white;
        transition: all 0.2s;
        margin: 0;
        width: auto;
    }

    .icon-btn:hover {
        transform: scale(1.05);
    }

    .btn-delete {
        background: #f5222d;
    }

    .btn-edit {
        background: #1890ff;
    }

    .color-preview {
        width: 30px;
        height: 30px;
        border-radius: 4px;
        border: 2px solid #ddd;
        display: inline-block;
        vertical-align: middle;
        margin-left: 8px;
    }

    .image-upload-group {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
    }

    .image-upload-item {
        flex: 1;
    }

    .image-preview {
        width: 100%;
        height: 100px;
        object-fit: cover;
        border-radius: 4px;
        margin-top: 8px;
        border: 2px solid #e0e0e0;
    }

    /* æ‰¹é‡ç”Ÿæˆè¿›åº¦ */
    .progress-section {
        margin-top: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
        display: none;
    }

    .progress-bar {
        width: 100%;
        height: 20px;
        background: #e0e0e0;
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 10px;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        transition: width 0.3s;
    }

    .progress-text {
        text-align: center;
        color: #666;
        font-size: 13px;
    }

    /* ç”Ÿæˆç»“æœç½‘æ ¼ */
    .result-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 20px;
    }

    .result-item {
        background: white;
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .result-image {
        width: 100%;
        border-radius: 4px;
        margin-bottom: 8px;
    }

    .result-name {
        font-size: 12px;
        font-weight: bold;
        margin-bottom: 5px;
        color: #333;
    }

    .result-download {
        width: 100%;
        padding: 6px;
        font-size: 11px;
        margin: 0;
    }

    .warning-text {
        font-size: 11px;
        color: #f5222d;
        margin-top: 5px;
    }

    /* æ·»åŠ å®æ—¶é¢„è§ˆæ ·å¼ */
    .live-preview-container {
        margin-top: 20px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        overflow: hidden;
    }

    .live-preview-header {
        padding: 10px 15px;
        background: #f8f9fa;
        border-bottom: 1px solid #e0e0e0;
        font-size: 13px;
        font-weight: bold;
        color: #555;
    }

    .live-preview-content {
        padding: 15px;
        min-height: 100px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .live-preview-text {
        padding: 10px 15px;
        border-radius: 6px;
        margin-top: 10px;
        font-weight: bold;
        text-align: center;
    }
</style>
</head>
<body>
<div class="container">
    <!-- å·¦ä¾§è¾“å…¥é¢æ¿ -->
    <div class="panel">
        <h2>ğŸ“Š ç­–ç•¥å‚æ•°è¾“å…¥</h2>
        
        <!-- é¢‘é“é€‰æ‹© -->
        <div class="channel-section">
            <h3>ğŸ“¢ é¢‘é“é…ç½®</h3>
            <div class="channel-grid" id="channelGrid">
                <!-- é¢‘é“å¡ç‰‡å°†é€šè¿‡ JS åŠ¨æ€ç”Ÿæˆ -->
            </div>
            <div class="channel-actions">
                <button class="channel-btn btn-add" onclick="openAddChannelModal()">â• æ·»åŠ é¢‘é“</button>
                <button class="channel-btn btn-manage" onclick="openManageChannelModal()">âš™ï¸ ç®¡ç†é¢‘é“</button>
                <button class="channel-btn btn-export" onclick="exportChannelConfig()">ğŸ“¦ å¯¼å‡ºé…ç½®</button>
                <button class="channel-btn btn-import" onclick="triggerImportConfig()">ğŸ“¥ å¯¼å…¥é…ç½®</button>
            </div>
            <input type="file" id="importConfigInput" accept="application/json" style="display:none" onchange="handleImportConfig(event)">
        </div>

        <div class="form-group">
            <label>ç­–ç•¥ç¼–å·</label>
            <input type="text" id="strategy_id" value="209898" placeholder="ä¾‹å¦‚: 209898">
        </div>
        
        <div class="form-group">
            <label>äº¤æ˜“æ ‡çš„</label>
            <select id="symbol_name">
                <option value="BTC">BTC</option>
                <option value="ETH">ETH</option>
            </select>
        </div>
        
        <div class="form-group">
            <label>æ“ä½œæ–¹å‘</label>
            <select id="direction">
                <option value="long">åšå¤š</option>
                <option value="short">åšç©º</option>
            </select>
        </div>
        
        <div class="form-group">
            <label>åŸºç¡€è¿›åœºä»·</label>
            <input type="number" id="entry_price" value="110947" placeholder="ä¾‹å¦‚: 110947">
        </div>

        <div class="style-section">
            <h3>ğŸ¨ å¯¼å‡ºè®¾ç½®</h3>
            <div class="form-group">
                <label>å›¾ç‰‡åˆ†è¾¨ç‡å€æ•°</label>
                <input type="number" id="exportScale" value="2" min="1" max="5" step="0.5">
            </div>
        </div>
        
        <button class="btn-generate-all" onclick="generateAllChannels()">ğŸš€ ä¸€é”®ç”Ÿæˆæ‰€æœ‰é¢‘é“å›¾ç‰‡</button>

        <!-- è¿›åº¦æ˜¾ç¤º -->
        <div class="progress-section" id="progressSection">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">å‡†å¤‡ç”Ÿæˆ...</div>
        </div>
    </div>
    
    <!-- å³ä¾§é¢„è§ˆé¢æ¿ -->
    <div class="panel preview-section">
        <h2>ğŸ–¼ï¸ é¢„è§ˆä¸ä¸‹è½½</h2>
        <canvas id="canvas" width="800" height="1000" style="display:none;"></canvas>
        <div class="result-grid" id="resultGrid">
            <div style="text-align:center;color:#999;padding:40px;grid-column:1/-1;">
                ç‚¹å‡»"ä¸€é”®ç”Ÿæˆæ‰€æœ‰é¢‘é“å›¾ç‰‡"å¼€å§‹ç”Ÿæˆ
            </div>
        </div>
    </div>
</div>

<!-- æ·»åŠ é¢‘é“å¼¹çª— -->
<div id="addChannelModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="channelModalTitle">â• æ·»åŠ æ–°é¢‘é“</h2>
            <span class="close" onclick="closeAddChannelModal()">&times;</span>
        </div>
        <div class="form-group">
            <label>é¢‘é“åç§°</label>
            <input type="text" id="channelName" placeholder="ä¾‹å¦‚: è‹±è¯­é¢‘é“" oninput="updateLivePreview()">
        </div>
        <div class="form-group">
            <label>é¢‘é“è¯­è¨€</label>
            <select id="channelLanguage">
                <option value="en">è‹±è¯­</option>
                <option value="ru">ä¿„è¯­</option>
                <option value="vi">è¶Šå—è¯­</option>
                <option value="ar">é˜¿æ‹‰ä¼¯è¯­</option>
            </select>
        </div>
        <div class="row">
            <div class="form-group">
                <label>æ–‡å­—é¢œè‰²</label>
                <input type="color" id="channelTextColor" value="#ffffff" oninput="updateLivePreview()">
            </div>
            <div class="form-group">
                <label>èƒŒæ™¯é¢œè‰²</label>
                <input type="color" id="channelBgColor" value="#1a1a2e" oninput="updateLivePreview()">
            </div>
        </div>
        <div class="row">
            <div class="form-group">
                <label>å­—ä½“å¤§å°</label>
                <input type="number" id="channelFontSize" value="38" min="12" max="72" oninput="updateLivePreview()">
            </div>
            <div class="form-group">
                <label>èƒŒæ™¯é€æ˜åº¦</label>
                <input type="number" id="channelBgOpacity" value="1" min="0" max="1" step="0.1" oninput="updateLivePreview()">
            </div>
        </div>
        
        <!-- æ·»åŠ å®æ—¶é¢„è§ˆåŒºåŸŸ -->
        <div class="live-preview-container">
            <div class="live-preview-header">å®æ—¶é¢„è§ˆæ•ˆæœ</div>
            <div class="live-preview-content" id="livePreviewContent">
                <div class="channel-preview" id="livePreviewBox" style="background: #1a1a2e; color: #ffffff;">
                    é¢„è§ˆæ–‡æœ¬
                </div>
                <div class="live-preview-text" id="livePreviewText" style="background: #1a1a2e; color: #ffffff;">
                    ç¤ºä¾‹æ–‡æœ¬
                </div>
            </div>
        </div>
        
        <div class="form-group">
            <label>åšå¤šå¤´å›¾ (å»ºè®®å°äº 500KB)</label>
            <input type="file" id="channelLongImage" accept="image/*">
            <img id="channelLongPreview" class="image-preview" style="display:none;">
            <div class="warning-text" id="longImageWarning" style="display:none;">âš ï¸ å›¾ç‰‡è¿‡å¤§ï¼Œå·²è‡ªåŠ¨å‹ç¼©</div>
        </div>
        <div class="form-group">
            <label>åšç©ºå¤´å›¾ (å»ºè®®å°äº 500KB)</label>
            <input type="file" id="channelShortImage" accept="image/*">
            <img id="channelShortPreview" class="image-preview" style="display:none;">
            <div class="warning-text" id="shortImageWarning" style="display:none;">âš ï¸ å›¾ç‰‡è¿‡å¤§ï¼Œå·²è‡ªåŠ¨å‹ç¼©</div>
        </div>
        <button id="channelModalSaveBtn" onclick="saveChannel()">ğŸ’¾ ä¿å­˜é¢‘é“</button>
    </div>
</div>

<!-- ç®¡ç†é¢‘é“å¼¹çª— -->
<div id="manageChannelModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>âš™ï¸ ç®¡ç†é¢‘é“</h2>
            <span class="close" onclick="closeManageChannelModal()">&times;</span>
        </div>
        <div class="channel-list" id="channelList">
            <!-- é¢‘é“åˆ—è¡¨å°†é€šè¿‡ JS åŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>
</div>

<script>
    // è¯­è¨€æ¨¡æ¿ - ä¿®æ”¹ä¸ºæ”¯æŒæ¢è¡Œçš„æ ¼å¼
    const templates = {
        en: {
            title: "âœ… Strategy ID {strategy_id}",
            lines: [
                "{symbol_name} (Total Position {total_position_pct}%)",
                "Entry Range: {price_low} â€“ {price_high}",
                "Direction: {direction}",
                "Max Position Size: {total_position_pct}%",
                "Leverage: {leverage}x",
                "Partial Take-Profit Prices:",
                "{tp1} / {tp2} / {tp3}"
            ],
            slLine: "Stop Loss: {sl}",
            align: "left",
            font: "Arial, sans-serif",
            directionLabels: { long: 'Long', short: 'Short' }
        },
        ru: {
            title: "âœ… Ğ¡Ñ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ â„–{strategy_id}",
            lines: [
                "{symbol_name} (ĞĞ±Ñ‰Ğ¸Ğ¹ Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ {total_position_pct}%)",
                "Ğ”Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½ Ğ²Ñ…Ğ¾Ğ´Ğ°: {price_low} â€“ {price_high}",
                "ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ: {direction}",
                "ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸: {total_position_pct}%",
                "ĞŸĞ»ĞµÑ‡Ğ¾: {leverage}x",
                "Ğ¦ĞµĞ½Ñ‹ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾Ğ¹ Ñ„Ğ¸ĞºÑĞ°Ñ†Ğ¸Ğ¸ Ğ¿Ñ€Ğ¸Ğ±Ñ‹Ğ»Ğ¸:",
                "{tp1} / {tp2} / {tp3}"
            ],
            slLine: "Ğ¡Ñ‚Ğ¾Ğ¿-Ğ»Ğ¾ÑÑ: {sl}",
            align: "left",
            font: "Arial, sans-serif",
            directionLabels: { long: 'Ğ”Ğ»Ğ¸Ğ½Ğ½Ğ°Ñ', short: 'ĞšĞ¾Ñ€Ğ¾Ñ‚ĞºĞ°Ñ' }
        },
        vi: {
            title: "âœ… Chiáº¿n lÆ°á»£c sá»‘ {strategy_id}",
            lines: [
                "{symbol_name} (Tá»•ng vá»‹ tháº¿ {total_position_pct}%)",
                "VÃ¹ng vÃ o lá»‡nh: {price_low} â€“ {price_high}",
                "HÆ°á»›ng giao dá»‹ch: {direction}",
                "Giá»›i háº¡n vá»‹ tháº¿: {total_position_pct}%",
                "ÄÃ²n báº©y: {leverage}x",
                "GiÃ¡ chá»‘t lá»i tá»«ng pháº§n:",
                "{tp1} / {tp2} / {tp3}"
            ],
            slLine: "Cáº¯t lá»—: {sl}",
            align: "left",
            font: "Arial, sans-serif",
            directionLabels: { long: 'Mua (Long)', short: 'BÃ¡n (Short)' }
        },
        ar: {
            title: "âœ… Ø±Ù‚Ù… Ø§Ù„Ø¥Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© {strategy_id}",
            lines: [
                "{symbol_name} (Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø© {total_position_pct}%)",
                "Ù†Ø·Ø§Ù‚ Ø§Ù„Ø¯Ø®ÙˆÙ„: {price_low} â€“ {price_high}",
                "Ø§Ù„Ø§ØªØ¬Ø§Ù‡: {direction}",
                "Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ø­Ø¬Ù… Ø§Ù„ØµÙÙ‚Ø©: {total_position_pct}%",
                "Ø§Ù„Ø±Ø§ÙØ¹Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ©: {leverage}x",
                "Ø£Ø³Ø¹Ø§Ø± Ø¬Ù†ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­ Ø§Ù„Ø¬Ø²Ø¦ÙŠØ©:",
                "{tp1} / {tp2} / {tp3}"
            ],
            slLine: "Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©: {sl}",
            align: "right",
            font: "Arial, sans-serif",
            directionLabels: { long: 'Ø´Ø±Ø§Ø¡', short: 'Ø¨ÙŠØ¹' }
        }
    };

    let currentActiveChannel = null;
    let channelLongImageData = null;
    let channelShortImageData = null;
    let currentEditIndex = null;

    // ========== å›¾ç‰‡å‹ç¼©å‡½æ•° ==========
    function compressImage(file, maxWidth = 800, quality = 0.7) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;

                    // é™åˆ¶æœ€å¤§å®½åº¦
                    if (width > maxWidth) {
                        height = Math.round(height * (maxWidth / width));
                        width = maxWidth;
                    }

                    canvas.width = width;
                    canvas.height = height;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // å‹ç¼©ä¸º JPEG æ ¼å¼
                    const compressed = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressed);
                };
                img.onerror = reject;
                img.src = e.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    // ========== é¢‘é“ç®¡ç†åŠŸèƒ½ ==========
    
    function getChannels() {
        try {
            return JSON.parse(localStorage.getItem('strategyChannels') || '[]');
        } catch (e) {
            console.error('è¯»å–é¢‘é“æ•°æ®å¤±è´¥:', e);
            return [];
        }
    }

    function saveChannels(channels) {
        try {
            localStorage.setItem('strategyChannels', JSON.stringify(channels));
        } catch (e) {
            if (e.name === 'QuotaExceededError') {
                alert('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼è¯·åˆ é™¤ä¸€äº›é¢‘é“æˆ–ä½¿ç”¨æ›´å°çš„å›¾ç‰‡ã€‚');
                throw e;
            }
        }
    }

    function exportChannelConfig() {
        const channels = getChannels();
        if (channels.length === 0) {
            alert('æš‚æ— é¢‘é“é…ç½®å¯å¯¼å‡º');
            return;
        }

        const payload = {
            type: 'strategy-channel-config',
            version: 1,
            exportedAt: new Date().toISOString(),
            channels
        };

        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `strategy_channels_${Date.now()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        showToast('é…ç½®å·²å¯¼å‡º');
    }

    function triggerImportConfig() {
        const input = document.getElementById('importConfigInput');
        if (!input) return;
        input.value = '';
        input.click();
    }

    async function handleImportConfig(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
            const text = await file.text();
            const parsed = JSON.parse(text);
            const candidates = Array.isArray(parsed) ? parsed : parsed.channels;

            if (!Array.isArray(candidates) || candidates.length === 0) {
                alert('é…ç½®æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°é¢‘é“æ•°æ®');
                return;
            }

            const existing = getChannels();
            const existingNames = new Set(existing.map(item => item.name));
            const merged = [...existing];
            let addedCount = 0;
            const importTimestamp = Date.now();

            candidates.forEach(original => {
                const normalized = normalizeImportedChannel(original);
                if (!normalized) return;

                normalized.name = ensureUniqueChannelName(normalized.name, existingNames);
                normalized.createdAt = normalized.createdAt || importTimestamp;
                normalized.updatedAt = importTimestamp;

                merged.push(normalized);
                addedCount++;
            });

            if (addedCount === 0) {
                alert('æœªèƒ½å¯¼å…¥ä»»ä½•æœ‰æ•ˆé¢‘é“ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶å†…å®¹');
                return;
            }

            saveChannels(merged);
            renderChannelGrid();
            renderChannelList();
            showToast(`æˆåŠŸå¯¼å…¥ ${addedCount} ä¸ªé¢‘é“`);
        } catch (error) {
            console.error('å¯¼å…¥é…ç½®å¤±è´¥:', error);
            alert('å¯¼å…¥å¤±è´¥ï¼Œè¯·ç¡®è®¤æ–‡ä»¶æ ¼å¼æ­£ç¡®');
        } finally {
            event.target.value = '';
        }
    }

    function normalizeImportedChannel(channel) {
        if (!channel) return null;

        const name = typeof channel.name === 'string' ? channel.name.trim() : '';
        const longImage = channel.longImage;
        const shortImage = channel.shortImage;

        if (
            !name ||
            typeof longImage !== 'string' ||
            typeof shortImage !== 'string' ||
            !longImage.startsWith('data:image') ||
            !shortImage.startsWith('data:image')
        ) {
            return null;
        }

        let fontSize = parseInt(channel.fontSize, 10);
        if (isNaN(fontSize) || fontSize <= 0) {
            fontSize = 38;
        }

        let bgOpacity = parseFloat(channel.bgOpacity);
        if (isNaN(bgOpacity)) {
            bgOpacity = 1;
        }
        bgOpacity = Math.min(Math.max(bgOpacity, 0), 1);

        return {
            name,
            language: channel.language || 'en',
            textColor: channel.textColor || '#ffffff',
            bgColor: channel.bgColor || '#1a1a2e',
            fontSize,
            bgOpacity,
            longImage,
            shortImage,
            createdAt: channel.createdAt || channel.updatedAt || Date.now()
        };
    }

    function ensureUniqueChannelName(baseName, existingNames) {
        let candidate = baseName || 'æœªå‘½åé¢‘é“';
        if (!existingNames.has(candidate)) {
            existingNames.add(candidate);
            return candidate;
        }

        let index = 2;
        while (existingNames.has(`${candidate} (${index})`)) {
            index++;
        }

        const uniqueName = `${candidate} (${index})`;
        existingNames.add(uniqueName);
        return uniqueName;
    }

    function renderChannelGrid() {
        const grid = document.getElementById('channelGrid');
        const channels = getChannels();
        
        if (channels.length === 0) {
            grid.innerHTML = '<div style="grid-column: 1/-1; text-align:center; color:white; padding:20px;">æš‚æ— é¢‘é“ï¼Œç‚¹å‡»"æ·»åŠ é¢‘é“"åˆ›å»º</div>';
            return;
        }

        grid.innerHTML = '';
        channels.forEach((channel, index) => {
            const card = document.createElement('div');
            card.className = 'channel-card';
            if (currentActiveChannel === index) {
                card.classList.add('active');
            }
            
            const languageMap = {
                'en': 'è‹±è¯­',
                'ru': 'ä¿„è¯­',
                'vi': 'è¶Šå—è¯­',
                'ar': 'é˜¿æ‹‰ä¼¯è¯­'
            };

            card.innerHTML = `
                <div class="channel-preview" style="background: ${channel.bgColor}; color: ${channel.textColor};">
                    ${channel.name}
                </div>
                <div class="channel-name">${channel.name}</div>
                <div class="channel-info">
                    <div>è¯­è¨€: ${languageMap[channel.language] || channel.language}</div>
                    <div>å­—å·: ${channel.fontSize}px</div>
                </div>
            `;
            
            card.onclick = () => {
                currentActiveChannel = index;
                renderChannelGrid();
                showToast(`å·²é€‰æ‹©é¢‘é“: ${channel.name}`);
            };
            grid.appendChild(card);
        });
    }

    function resetChannelForm() {
        document.getElementById('channelName').value = '';
        document.getElementById('channelLanguage').value = 'en';
        document.getElementById('channelTextColor').value = '#ffffff';
        document.getElementById('channelBgColor').value = '#1a1a2e';
        document.getElementById('channelFontSize').value = 38;
        document.getElementById('channelBgOpacity').value = 1;
        document.getElementById('channelLongImage').value = '';
        document.getElementById('channelShortImage').value = '';

        const longPreview = document.getElementById('channelLongPreview');
        const shortPreview = document.getElementById('channelShortPreview');
        longPreview.style.display = 'none';
        longPreview.removeAttribute('src');
        shortPreview.style.display = 'none';
        shortPreview.removeAttribute('src');

        document.getElementById('longImageWarning').style.display = 'none';
        document.getElementById('shortImageWarning').style.display = 'none';

        channelLongImageData = null;
        channelShortImageData = null;
        currentEditIndex = null;

        updateLivePreview();
    }

    function openAddChannelModal() {
        resetChannelForm();
        document.getElementById('channelModalTitle').textContent = 'â• æ·»åŠ æ–°é¢‘é“';
        const saveBtn = document.getElementById('channelModalSaveBtn');
        saveBtn.textContent = 'ğŸ’¾ ä¿å­˜é¢‘é“';
        saveBtn.dataset.mode = 'add';
        document.getElementById('addChannelModal').style.display = 'block';
    }

    function openEditChannelModal(index) {
        const channels = getChannels();
        if (!Array.isArray(channels) || !channels[index]) {
            alert('æœªæ‰¾åˆ°éœ€è¦ç¼–è¾‘çš„é¢‘é“');
            return;
        }

        closeManageChannelModal();
        resetChannelForm();

        const channel = channels[index];
        currentEditIndex = index;

        document.getElementById('channelModalTitle').textContent = 'âœï¸ ç¼–è¾‘é¢‘é“';
        const saveBtn = document.getElementById('channelModalSaveBtn');
        saveBtn.textContent = 'ğŸ’¾ æ›´æ–°é¢‘é“';
        saveBtn.dataset.mode = 'edit';

        document.getElementById('channelName').value = channel.name || '';
        document.getElementById('channelLanguage').value = channel.language || 'en';
        document.getElementById('channelTextColor').value = channel.textColor || '#ffffff';
        document.getElementById('channelBgColor').value = channel.bgColor || '#1a1a2e';
        document.getElementById('channelFontSize').value = channel.fontSize || 38;
        document.getElementById('channelBgOpacity').value = (channel.bgOpacity !== undefined && channel.bgOpacity !== null) ? channel.bgOpacity : 1;

        channelLongImageData = channel.longImage || null;
        channelShortImageData = channel.shortImage || null;

        const longPreview = document.getElementById('channelLongPreview');
        const shortPreview = document.getElementById('channelShortPreview');

        if (channelLongImageData) {
            longPreview.src = channelLongImageData;
            longPreview.style.display = 'block';
        }

        if (channelShortImageData) {
            shortPreview.src = channelShortImageData;
            shortPreview.style.display = 'block';
        }

        document.getElementById('addChannelModal').style.display = 'block';
        updateLivePreview();
    }

    function closeAddChannelModal() {
        document.getElementById('addChannelModal').style.display = 'none';
        resetChannelForm();
        document.getElementById('channelModalTitle').textContent = 'â• æ·»åŠ æ–°é¢‘é“';
        const saveBtn = document.getElementById('channelModalSaveBtn');
        saveBtn.textContent = 'ğŸ’¾ ä¿å­˜é¢‘é“';
        saveBtn.dataset.mode = 'add';
    }

    // å®æ—¶é¢„è§ˆåŠŸèƒ½
    function updateLivePreview() {
        const name = document.getElementById('channelName').value.trim() || 'é¢„è§ˆæ–‡æœ¬';
        const textColor = document.getElementById('channelTextColor').value;
        const bgColor = document.getElementById('channelBgColor').value;
        const fontSize = parseInt(document.getElementById('channelFontSize').value) || 38;
        let bgOpacity = parseFloat(document.getElementById('channelBgOpacity').value);
        if (isNaN(bgOpacity)) {
            bgOpacity = 1;
        }
        bgOpacity = Math.min(Math.max(bgOpacity, 0), 1);
        
        // æ›´æ–°é¢„è§ˆæ¡†
        const previewBox = document.getElementById('livePreviewBox');
        previewBox.style.background = bgColor;
        previewBox.style.color = textColor;
        previewBox.style.fontSize = `${fontSize}px`;
        previewBox.textContent = name;
        
        // æ›´æ–°æ–‡æœ¬é¢„è§ˆ
        const previewText = document.getElementById('livePreviewText');
        previewText.style.background = bgColor;
        previewText.style.color = textColor;
        previewText.style.fontSize = `${fontSize}px`;
        previewText.style.opacity = bgOpacity;
        previewText.textContent = 'ç¤ºä¾‹æ–‡æœ¬';
    }

    // é¢„è§ˆå¹¶å‹ç¼©ä¸Šä¼ çš„å›¾ç‰‡
    document.getElementById('channelLongImage').addEventListener('change', async function(e) {
        const file = e.target.files[0];
        if (file) {
            try {
                // æ˜¾ç¤ºå‹ç¼©æç¤º
                if (file.size > 500 * 1024) {
                    document.getElementById('longImageWarning').style.display = 'block';
                } else {
                    document.getElementById('longImageWarning').style.display = 'none';
                }

                channelLongImageData = await compressImage(file, 800, 0.7);
                const preview = document.getElementById('channelLongPreview');
                preview.src = channelLongImageData;
                preview.style.display = 'block';
            } catch (error) {
                alert('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
                console.error(error);
            }
        }
    });

    document.getElementById('channelShortImage').addEventListener('change', async function(e) {
        const file = e.target.files[0];
        if (file) {
            try {
                if (file.size > 500 * 1024) {
                    document.getElementById('shortImageWarning').style.display = 'block';
                } else {
                    document.getElementById('shortImageWarning').style.display = 'none';
                }

                channelShortImageData = await compressImage(file, 800, 0.7);
                const preview = document.getElementById('channelShortPreview');
                preview.src = channelShortImageData;
                preview.style.display = 'block';
            } catch (error) {
                alert('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
                console.error(error);
            }
        }
    });

    async function saveChannel() {
        const name = document.getElementById('channelName').value.trim();
        const language = document.getElementById('channelLanguage').value;
        const textColor = document.getElementById('channelTextColor').value;
        const bgColor = document.getElementById('channelBgColor').value;
        let fontSize = parseInt(document.getElementById('channelFontSize').value, 10);
        let bgOpacity = parseFloat(document.getElementById('channelBgOpacity').value);
        
        if (!name) {
            alert('è¯·è¾“å…¥é¢‘é“åç§°');
            return;
        }

        if (!channelLongImageData || !channelShortImageData) {
            alert('è¯·ä¸Šä¼ åšå¤šå’Œåšç©ºå¤´å›¾');
            return;
        }

        if (isNaN(fontSize) || fontSize <= 0) {
            fontSize = 38;
        }

        if (isNaN(bgOpacity)) {
            bgOpacity = 1;
        }
        bgOpacity = Math.min(Math.max(bgOpacity, 0), 1);

        try {
            const channels = getChannels();
            const timestamp = Date.now();
            const isEdit = Number.isInteger(currentEditIndex) && currentEditIndex >= 0 && currentEditIndex < channels.length;

            const payload = {
                name,
                language,
                textColor,
                bgColor,
                fontSize,
                bgOpacity,
                longImage: channelLongImageData,
                shortImage: channelShortImageData,
                updatedAt: timestamp
            };

            let toastMessage = 'é¢‘é“å·²ä¿å­˜';

            if (isEdit) {
                const existing = channels[currentEditIndex];
                payload.createdAt = existing.createdAt || timestamp;
                channels[currentEditIndex] = { ...existing, ...payload };
                toastMessage = 'é¢‘é“å·²æ›´æ–°';
            } else {
                payload.createdAt = timestamp;
                channels.push(payload);
            }

            saveChannels(channels);

            renderChannelGrid();
            renderChannelList();
            closeAddChannelModal();
            showToast(toastMessage);
        } catch (error) {
            console.error('ä¿å­˜é¢‘é“å¤±è´¥:', error);
        }
    }

    function openManageChannelModal() {
        document.getElementById('manageChannelModal').style.display = 'block';
        renderChannelList();
    }

    function closeManageChannelModal() {
        document.getElementById('manageChannelModal').style.display = 'none';
    }

    function renderChannelList() {
        const list = document.getElementById('channelList');
        const channels = getChannels();
        
        if (channels.length === 0) {
            list.innerHTML = '<div style="text-align:center;color:#999;padding:40px;">æš‚æ— é¢‘é“</div>';
            return;
        }

        list.innerHTML = '';
        channels.forEach((channel, index) => {
            const item = document.createElement('div');
            item.className = 'channel-item';
            
            const languageMap = {
                'en': 'è‹±è¯­',
                'ru': 'ä¿„è¯­',
                'vi': 'è¶Šå—è¯­',
                'ar': 'é˜¿æ‹‰ä¼¯è¯­'
            };

            item.innerHTML = `
                <div class="channel-item-info">
                    <div style="font-weight:bold;margin-bottom:5px;">${channel.name}</div>
                    <div style="font-size:12px;color:#666;">
                        ${languageMap[channel.language]} | å­—å·: ${channel.fontSize}px
                        <span class="color-preview" style="background:${channel.textColor}"></span>
                        <span class="color-preview" style="background:${channel.bgColor}"></span>
                    </div>
                </div>
                <div class="channel-item-actions">
                    <button class="icon-btn btn-edit" onclick="openEditChannelModal(${index})">âœï¸ ç¼–è¾‘</button>
                    <button class="icon-btn btn-delete" onclick="deleteChannel(${index})">ğŸ—‘ï¸ åˆ é™¤</button>
                </div>
            `;
            
            list.appendChild(item);
        });
    }

    function deleteChannel(index) {
        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªé¢‘é“å—ï¼Ÿ')) return;
        
        const channels = getChannels();
        channels.splice(index, 1);
        saveChannels(channels);
        
        renderChannelList();
        renderChannelGrid();
        showToast('é¢‘é“å·²åˆ é™¤');
    }

    // ========== æ‰¹é‡ç”ŸæˆåŠŸèƒ½ ==========

    async function generateAllChannels() {
        const channels = getChannels();
        
        if (channels.length === 0) {
            alert('è¯·å…ˆæ·»åŠ é¢‘é“é…ç½®');
            return;
        }

        const strategyId = document.getElementById('strategy_id').value;
        const symbolName = document.getElementById('symbol_name').value;
        const direction = document.getElementById('direction').value;
        const entryPrice = parseFloat(document.getElementById('entry_price').value);

        if (!strategyId || !entryPrice) {
            alert('è¯·å¡«å†™å®Œæ•´çš„ç­–ç•¥å‚æ•°');
            return;
        }

        // æ˜¾ç¤ºè¿›åº¦
        const progressSection = document.getElementById('progressSection');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        progressSection.style.display = 'block';

        const resultGrid = document.getElementById('resultGrid');
        resultGrid.innerHTML = '';

        const exportScale = parseFloat(document.getElementById('exportScale').value) || 2;

        for (let i = 0; i < channels.length; i++) {
            const channel = channels[i];
            const progress = ((i + 1) / channels.length) * 100;
            
            progressFill.style.width = progress + '%';
            progressText.textContent = `æ­£åœ¨ç”Ÿæˆ ${channel.name} (${i + 1}/${channels.length})`;

            // ç”Ÿæˆå›¾ç‰‡
            const imageDataUrl = await generateChannelImage(channel, {
                strategyId,
                symbolName,
                direction,
                entryPrice
            }, exportScale);

            // æ·»åŠ åˆ°ç»“æœç½‘æ ¼
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            resultItem.innerHTML = `
                <img src="${imageDataUrl}" class="result-image" alt="${channel.name}">
                <div class="result-name">${channel.name}</div>
                <button class="result-download" onclick="downloadChannelImage('${imageDataUrl}', '${strategyId}', '${channel.name}')">
                    â¬‡ï¸ ä¸‹è½½
                </button>
            `;
            resultGrid.appendChild(resultItem);

            // çŸ­æš‚å»¶è¿Ÿï¼Œè®©UIæ›´æ–°
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        progressText.textContent = `âœ… å®Œæˆï¼å·²ç”Ÿæˆ ${channels.length} å¼ å›¾ç‰‡`;
        showToast('æ‰€æœ‰é¢‘é“å›¾ç‰‡ç”Ÿæˆå®Œæˆï¼');
    }

    function generateChannelImage(channel, strategyData, scale = 2) {
        return new Promise((resolve) => {
            const canvas = document.getElementById('canvas');
            const { strategyId, symbolName, direction, entryPrice } = strategyData;

            // è®¡ç®—ç­–ç•¥å‚æ•°
            const calculated = calculateStrategy(symbolName, entryPrice, direction);
            
            const data = {
                strategy_id: strategyId,
                symbol_name: symbolName,
                direction: direction,
                entry_price: entryPrice,
                ...calculated
            };

            // è·å–æ¨¡æ¿
            const template = templates[channel.language] || templates['en'];
            const dirValue = direction;
            const localizedDirection = (template.directionLabels && template.directionLabels[dirValue]) ? 
                template.directionLabels[dirValue] : (dirValue === 'long' ? 'Long' : 'Short');
            
            data.direction = localizedDirection;

            // åŠ è½½å¯¹åº”çš„å¤´å›¾
            const headerImageSrc = direction === 'long' ? channel.longImage : channel.shortImage;
            const headerImage = new Image();
            
            headerImage.onload = () => {
                // è®¾ç½®ç”»å¸ƒå°ºå¯¸
                const baseWidth = 800;
                canvas.width = baseWidth * scale;

                const scaleFactor = scale;
                const paddingScaled = Math.round(30 * scaleFactor);
                const baseFontSize = channel.fontSize || 38;
                const fontSizeScaled = Math.round(baseFontSize * scaleFactor);
                const titleFontScaled = Math.round((baseFontSize + 4) * scaleFactor);
                const lineHeight = fontSizeScaled * 1.8;
                
                let titleText = template.title.replace(/{(\w+)}/g, (m,k) => data[k] || m);
                let contentLines = template.lines.map(line => line.replace(/{(\w+)}/g, (m,k) => data[k] || m));
                let slLineText = template.slLine.replace(/{(\w+)}/g, (m,k) => data[k] || m);

                if (channel.language === 'ar') {
                    const bidiFix = applyArabicBidiFix;
                    titleText = bidiFix(titleText);
                    contentLines = contentLines.map(bidiFix);
                    slLineText = bidiFix(slLineText);
                }

                // åˆ›å»ºä¸´æ—¶ canvas ç”¨äºæµ‹é‡æ–‡æœ¬å®½åº¦
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.font = `bold ${fontSizeScaled}px ${template.font}`;
                
                // è®¡ç®—å¯ç”¨å®½åº¦ï¼ˆè€ƒè™‘paddingï¼‰
                const availableWidth = canvas.width - paddingScaled * 2 - Math.round(40 * scaleFactor);
                
                // æ£€æµ‹æ­¢ç›ˆä»·æ ¼è¡Œæ˜¯å¦éœ€è¦æ¢è¡Œ
                let tpPricesLine = contentLines[contentLines.length - 1]; // æœ€åä¸€è¡Œæ˜¯æ­¢ç›ˆä»·æ ¼
                let tpLabelLine = contentLines[contentLines.length - 2]; // å€’æ•°ç¬¬äºŒè¡Œæ˜¯æ ‡ç­¾
                let needWrapTP = false;
                
                // æ£€æµ‹æ­¢ç›ˆä»·æ ¼è¡Œå®½åº¦
                const tpLineWidth = tempCtx.measureText(tpPricesLine).width;
                if (tpLineWidth > availableWidth) {
                    needWrapTP = true;
                }
                
                // æ£€æµ‹æ­¢æŸè¡Œæ˜¯å¦éœ€è¦æ¢è¡Œ
                let needWrapSL = false;
                const slLineWidth = tempCtx.measureText(slLineText).width;
                if (slLineWidth > availableWidth) {
                    needWrapSL = true;
                }

                // è®¡ç®—å®é™…éœ€è¦çš„è¡Œæ•°
                let totalLines = contentLines.length;
                if (needWrapTP) totalLines++; // æ­¢ç›ˆæ¢è¡Œå¢åŠ ä¸€è¡Œ
                totalLines++; // æ­¢æŸè¡Œ
                if (needWrapSL) totalLines++; // æ­¢æŸæ¢è¡Œå¢åŠ ä¸€è¡Œ

                const bgHeight = Math.round(lineHeight * (totalLines + 1) + paddingScaled * 2);

                // è®¡ç®—å¤´å›¾é«˜åº¦
                const canvasWidth = canvas.width;
                const imgAspect = headerImage.width / headerImage.height;
                const headerDrawHeight = Math.round(canvasWidth / imgAspect);

                const bottomPadding = 40;
                const totalHeight = headerDrawHeight + bgHeight + bottomPadding;

                canvas.height = Math.max(totalHeight, 200);
                const ctx = canvas.getContext('2d', { alpha: false });
                
                ctx.imageSmoothingEnabled = false;

                // æ¸…ç©ºç”»å¸ƒ
                ctx.fillStyle = channel.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ç»˜åˆ¶å¤´å›¾
                ctx.drawImage(headerImage, 0, 0, canvasWidth, headerDrawHeight);

                // ç»˜åˆ¶æ–‡å­—èƒŒæ™¯
                const bgY = headerDrawHeight;
                ctx.globalAlpha = channel.bgOpacity;
                ctx.fillStyle = channel.bgColor;
                roundRect(ctx, paddingScaled, bgY, canvas.width - paddingScaled * 2, bgHeight, 15 * scaleFactor);
                ctx.fill();
                ctx.globalAlpha = 1;

                // ç»˜åˆ¶æ–‡å­—
                ctx.fillStyle = channel.textColor;
                ctx.font = `bold ${titleFontScaled}px ${template.font}`;
                ctx.textAlign = template.align;
                ctx.direction = template.align === 'right' ? 'rtl' : 'ltr';
                
                const textX = template.align === 'right' ? 
                    canvas.width - paddingScaled - Math.round(20 * scaleFactor) : 
                    paddingScaled + Math.round(20 * scaleFactor);
                let textY = bgY + paddingScaled + fontSizeScaled + Math.round(10 * scaleFactor);

                ctx.fillText(titleText, textX, textY);

                ctx.font = `bold ${fontSizeScaled}px ${template.font}`;
                textY += lineHeight * 1.5;
                
                // ç»˜åˆ¶å†…å®¹è¡Œï¼ˆä¸åŒ…æ‹¬æœ€åä¸¤è¡Œï¼Œå› ä¸ºå®ƒä»¬æ˜¯æ­¢ç›ˆç›¸å…³ï¼‰
                for (let i = 0; i < contentLines.length - 2; i++) {
                    const line = contentLines[i];
                    if (line.includes(localizedDirection)) {
                        ctx.save();
                        if (direction === 'long') {
                            ctx.fillStyle = '#00DA90';
                        } else if (direction === 'short') {
                            ctx.fillStyle = '#F04343';
                        }
                        ctx.fillText(line, textX, textY);
                        ctx.restore();
                    } else {
                        ctx.fillText(line, textX, textY);
                    }
                    textY += lineHeight;
                }

                // ç»˜åˆ¶æ­¢ç›ˆæ ‡ç­¾å’Œä»·æ ¼ï¼ˆå¯èƒ½æ¢è¡Œï¼‰
                if (needWrapTP) {
                    // æ¢è¡Œæ˜¾ç¤ºï¼šæ ‡ç­¾å•ç‹¬ä¸€è¡Œï¼Œä»·æ ¼å•ç‹¬ä¸€è¡Œ
                    ctx.fillText(tpLabelLine, textX, textY);
                    textY += lineHeight;
                    ctx.fillText(tpPricesLine, textX, textY);
                    textY += lineHeight;
                } else {
                    // ä¸æ¢è¡Œï¼šæŒ‰åŸæ ·æ˜¾ç¤º
                    ctx.fillText(tpLabelLine, textX, textY);
                    textY += lineHeight;
                    ctx.fillText(tpPricesLine, textX, textY);
                    textY += lineHeight;
                }

                // ç»˜åˆ¶æ­¢æŸè¡Œï¼ˆå¯èƒ½æ¢è¡Œï¼‰
                if (needWrapSL) {
                    // å°†æ­¢æŸè¡Œåˆ†æˆä¸¤éƒ¨åˆ†ï¼šæ ‡ç­¾å’Œæ•°å€¼
                    const slParts = slLineText.split(':');
                    if (slParts.length === 2) {
                        const slLabel = slParts[0] + ':';
                        const slValue = slParts[1].trim();
                        ctx.fillText(slLabel, textX, textY);
                        textY += lineHeight;
                        ctx.fillText(slValue, textX, textY);
                    } else {
                        ctx.fillText(slLineText, textX, textY);
                    }
                } else {
                    ctx.fillText(slLineText, textX, textY);
                }

                // è¿”å›å›¾ç‰‡æ•°æ®
                resolve(canvas.toDataURL('image/png'));
            };

            headerImage.src = headerImageSrc;
        });
    }

    function downloadChannelImage(dataUrl, strategyId, channelName) {
        const link = document.createElement('a');
        const safeName = channelName.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_');
        link.download = `strategy_${strategyId}_${safeName}.png`;
        link.href = dataUrl;
        link.click();
    }

    // ========== è¾…åŠ©å‡½æ•° ==========

    function calculateStrategy(symbolName, entryPrice, direction) {
        const symbol = symbolName.toUpperCase();
        const offset = symbol.includes('BTC') ? 100 : 10;
        const isLong = direction === 'long';
        
        return {
            price_low: Math.round(entryPrice - offset),
            price_high: Math.round(entryPrice + offset),
            leverage: 100,
            total_position_pct: 5,
            tp1: isLong ? Math.round(entryPrice * (1 + 0.012)) : Math.round(entryPrice * (1 - 0.012)),
            tp2: isLong ? Math.round(entryPrice * (1 + 0.018)) : Math.round(entryPrice * (1 - 0.018)),
            tp3: isLong ? Math.round(entryPrice * (1 + 0.03)) : Math.round(entryPrice * (1 - 0.03)),
            sl: isLong ? Math.round(entryPrice * (1 - 0.01)) : Math.round(entryPrice * (1 + 0.01))
        };
    }

    function roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
    }

    function applyArabicBidiFix(text) {
        if (!text || typeof text !== 'string') return text;
        const LRI = '\u2066';
        const PDI = '\u2069';
        const LRM = '\u200E';
        const tokenRegex = /([A-Za-z]+|\d+(?:[.,]\d+)?(?:\s*[\/\-â€“]\s*\d+(?:[.,]\d+)?)+|\d+(?:[.,]\d+)?(?:[%xX])?)/g;
        return text.replace(tokenRegex, (segment) => {
            if (!segment || segment.includes(LRI)) return segment;
            return `${LRI}${segment}${PDI}${LRM}`;
        });
    }

    function showToast(message) {
        const toast = document.createElement('div');
        toast.textContent = message;
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            z-index: 10000;
            animation: slideInRight 0.3s;
        `;
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.style.animation = 'fadeOut 0.3s';
            setTimeout(() => toast.remove(), 300);
        }, 2000);
    }

    window.onclick = function(event) {
        const addModal = document.getElementById('addChannelModal');
        const manageModal = document.getElementById('manageChannelModal');
        if (event.target === addModal) {
            closeAddChannelModal();
        }
        if (event.target === manageModal) {
            closeManageChannelModal();
        }
    };

    window.onload = () => {
        renderChannelGrid();
    };
</script>
</body>
</html>
